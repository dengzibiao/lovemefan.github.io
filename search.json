[{"title":"后端架构师技术图谱 --来自github","url":"/2018/09/05/《后端架构师技术图谱》/","content":"`原文地址`[https://github.com/xingshaocheng/architect-awesome](https://github.com/xingshaocheng/architect-awesome)\n`笔者只是Mark一下,侵删`\n<h1>《后端架构师技术图谱》</h1>\n\n\n[![知识共享协议（CC协议）](https://img.shields.io/badge/License-Creative%20Commons-DC3D24.svg)](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)\n[![GitHub stars](https://img.shields.io/github/stars/xingshaocheng/architect-awesome.svg?style=flat&label=Star)](https://github.com/xingshaocheng/architect-awesome/stargazers)\n[![GitHub forks](https://img.shields.io/github/forks/xingshaocheng/architect-awesome.svg?style=flat&label=Fork)](https://github.com/xingshaocheng/architect-awesome/fork)\n[![GitHub watchers](https://img.shields.io/github/watchers/xingshaocheng/architect-awesome.svg?style=flat&label=Watch)](https://github.com/xingshaocheng/architect-awesome/watchers)\n\n**更新于20180624**\n\n\n* [数据结构](/post/《后端架构师技术图谱》#数据结构)\n\t* [队列](/post/《后端架构师技术图谱》#队列)\n\t* [集合](/post/《后端架构师技术图谱》#集合)\n\t* [链表、数组](/post/《后端架构师技术图谱》#链表数组)\n\t* [字典、关联数组](/post/《后端架构师技术图谱》#字典关联数组)\n\t* [栈](/post/《后端架构师技术图谱》#栈)\n\t* [树](/post/《后端架构师技术图谱》#树)\n\t\t* [二叉树](/post/《后端架构师技术图谱》#二叉树)\n\t\t* [完全二叉树](/post/《后端架构师技术图谱》#完全二叉树)\n\t\t* [平衡二叉树](/post/《后端架构师技术图谱》#平衡二叉树)\n\t\t* [二叉查找树（BST）](/post/《后端架构师技术图谱》#二叉查找树bst)\n\t\t* [红黑树](/post/《后端架构师技术图谱》#红黑树)\n\t\t* [B-，B+，B*树](/post/《后端架构师技术图谱》#b-bb树)\n\t\t* [LSM 树](/post/《后端架构师技术图谱》#lsm-树)\n\t* [BitSet](/post/《后端架构师技术图谱》#bitset)\n* [常用算法](/post/《后端架构师技术图谱》#常用算法)\n\t* [排序、查找算法](/post/《后端架构师技术图谱》#排序查找算法)\n\t\t* [选择排序](/post/《后端架构师技术图谱》#选择排序)\n\t\t* [冒泡排序](/post/《后端架构师技术图谱》#冒泡排序)\n\t\t* [插入排序](/post/《后端架构师技术图谱》#插入排序)\n\t\t* [快速排序](/post/《后端架构师技术图谱》#快速排序)\n\t\t* [归并排序](/post/《后端架构师技术图谱》#归并排序)\n\t\t* [希尔排序](/post/《后端架构师技术图谱》#希尔排序)\n\t\t* [堆排序](/post/《后端架构师技术图谱》#堆排序)\n\t\t* [计数排序](/post/《后端架构师技术图谱》#计数排序)\n\t\t* [桶排序](/post/《后端架构师技术图谱》#桶排序)\n\t\t* [基数排序](/post/《后端架构师技术图谱》#基数排序)\n\t\t* [二分查找](/post/《后端架构师技术图谱》#二分查找)\n\t\t* [Java 中的排序工具](/post/《后端架构师技术图谱》#java-中的排序工具)\n\t* [布隆过滤器](/post/《后端架构师技术图谱》#布隆过滤器)\n\t* [字符串比较](/post/《后端架构师技术图谱》#字符串比较)\n\t\t* [KMP 算法](/post/《后端架构师技术图谱》#kmp-算法)\n\t* [深度优先、广度优先](/post/《后端架构师技术图谱》#深度优先广度优先)\n\t* [贪心算法](/post/《后端架构师技术图谱》#贪心算法)\n\t* [回溯算法](/post/《后端架构师技术图谱》#回溯算法)\n\t* [剪枝算法](/post/《后端架构师技术图谱》#剪枝算法)\n\t* [动态规划](/post/《后端架构师技术图谱》#动态规划)\n\t* [朴素贝叶斯](/post/《后端架构师技术图谱》#朴素贝叶斯)\n\t* [推荐算法](/post/《后端架构师技术图谱》#推荐算法)\n\t* [最小生成树算法](/post/《后端架构师技术图谱》#最小生成树算法)\n\t* [最短路径算法](/post/《后端架构师技术图谱》#最短路径算法)\n* [并发](/post/《后端架构师技术图谱》#并发)\n\t* [Java 并发](/post/《后端架构师技术图谱》#java-并发)\n\t* [多线程](/post/《后端架构师技术图谱》#多线程)\n\t* [线程安全](/post/《后端架构师技术图谱》#线程安全)\n\t* [一致性、事务](/post/《后端架构师技术图谱》#一致性事务)\n\t\t* [事务 ACID 特性](/post/《后端架构师技术图谱》#事务-acid-特性)\n\t\t* [事务的隔离级别](/post/《后端架构师技术图谱》#事务的隔离级别)\n\t\t* [MVCC](/post/《后端架构师技术图谱》#mvcc)\n\t* [锁](/post/《后端架构师技术图谱》#锁)\n\t\t* [Java中的锁和同步类](/post/《后端架构师技术图谱》#java中的锁和同步类)\n\t\t* [公平锁 &amp; 非公平锁](/post/《后端架构师技术图谱》#公平锁--非公平锁)\n\t\t* [悲观锁](/post/《后端架构师技术图谱》#悲观锁)\n\t\t* [乐观锁 &amp; CAS](/post/《后端架构师技术图谱》#乐观锁--cas)\n\t\t* [ABA 问题](/post/《后端架构师技术图谱》#aba-问题)\n\t\t* [CopyOnWrite容器](/post/《后端架构师技术图谱》#copyonwrite容器)\n\t\t* [RingBuffer](/post/《后端架构师技术图谱》#ringbuffer)\n\t\t* [可重入锁 &amp; 不可重入锁](/post/《后端架构师技术图谱》#可重入锁--不可重入锁)\n\t\t* [互斥锁 &amp; 共享锁](/post/《后端架构师技术图谱》#互斥锁--共享锁)\n\t\t* [死锁](/post/《后端架构师技术图谱》#死锁)\n* [操作系统](/post/《后端架构师技术图谱》#操作系统)\n\t* [计算机原理](/post/《后端架构师技术图谱》#计算机原理)\n\t* [CPU](/post/《后端架构师技术图谱》#cpu)\n\t\t* [多级缓存](/post/《后端架构师技术图谱》#多级缓存)\n\t* [进程](/post/《后端架构师技术图谱》#进程)\n\t* [线程](/post/《后端架构师技术图谱》#线程)\n\t* [协程](/post/《后端架构师技术图谱》#协程)\n\t* [Linux](/post/《后端架构师技术图谱》#linux)\n* [设计模式](/post/《后端架构师技术图谱》#设计模式)\n\t* [设计模式的六大原则](/post/《后端架构师技术图谱》#设计模式的六大原则)\n\t* [23种常见设计模式](/post/《后端架构师技术图谱》#23种常见设计模式)\n\t* [应用场景](/post/《后端架构师技术图谱》#应用场景)\n\t* [单例模式](/post/《后端架构师技术图谱》#单例模式)\n\t* [责任链模式](/post/《后端架构师技术图谱》#责任链模式)\n\t* [MVC](/post/《后端架构师技术图谱》#mvc)\n\t* [IOC](/post/《后端架构师技术图谱》#ioc)\n\t* [AOP](/post/《后端架构师技术图谱》#aop)\n\t* [UML](/post/《后端架构师技术图谱》#uml)\n\t* [微服务思想](/post/《后端架构师技术图谱》#微服务思想)\n\t\t* [康威定律](/post/《后端架构师技术图谱》#康威定律)\n* [运维 &amp; 统计 &amp; 技术支持](/post/《后端架构师技术图谱》#运维--统计--技术支持)\n\t* [常规监控](/post/《后端架构师技术图谱》#常规监控)\n\t* [APM](/post/《后端架构师技术图谱》#apm)\n\t* [统计分析](/post/《后端架构师技术图谱》#统计分析)\n\t* [持续集成(CI/CD)](/post/《后端架构师技术图谱》#持续集成cicd)\n\t\t* [Jenkins](/post/《后端架构师技术图谱》#jenkins)\n\t\t* [环境分离](/post/《后端架构师技术图谱》#环境分离)\n\t* [自动化运维](/post/《后端架构师技术图谱》#自动化运维)\n\t\t* [Ansible](/post/《后端架构师技术图谱》#ansible)\n\t\t* [puppet](/post/《后端架构师技术图谱》#puppet)\n\t\t* [chef](/post/《后端架构师技术图谱》#chef)\n\t* [测试](/post/《后端架构师技术图谱》#测试)\n\t\t* [TDD 理论](/post/《后端架构师技术图谱》#tdd-理论)\n\t\t* [单元测试](/post/《后端架构师技术图谱》#单元测试)\n\t\t* [压力测试](/post/《后端架构师技术图谱》#压力测试)\n\t\t* [全链路压测](/post/《后端架构师技术图谱》#全链路压测)\n\t\t* [A/B 、灰度、蓝绿测试](/post/《后端架构师技术图谱》#ab-灰度蓝绿测试)\n\t* [虚拟化](/post/《后端架构师技术图谱》#虚拟化)\n\t\t* [KVM](/post/《后端架构师技术图谱》#kvm)\n\t\t* [Xen](/post/《后端架构师技术图谱》#xen)\n\t\t* [OpenVZ](/post/《后端架构师技术图谱》#openvz)\n\t* [容器技术](/post/《后端架构师技术图谱》#容器技术)\n\t\t* [Docker](/post/《后端架构师技术图谱》#docker)\n\t* [云技术](/post/《后端架构师技术图谱》#云技术)\n\t\t* [OpenStack](/post/《后端架构师技术图谱》#openstack)\n\t* [DevOps](/post/《后端架构师技术图谱》#devops)\n\t* [文档管理](/post/《后端架构师技术图谱》#文档管理)\n* [中间件](/post/《后端架构师技术图谱》#中间件)\n\t* [Web Server](/post/《后端架构师技术图谱》#web-server)\n\t\t* [Nginx](/post/《后端架构师技术图谱》#nginx)\n\t\t* [OpenResty](/post/《后端架构师技术图谱》#openresty)  \n\t\t* [Tengine](/post/《后端架构师技术图谱》#Tengine)  \n\t\t* [Apache Httpd](/post/《后端架构师技术图谱》#apache-httpd)\n\t\t* [Tomcat](/post/《后端架构师技术图谱》#tomcat)\n\t\t\t* [架构原理](/post/《后端架构师技术图谱》#架构原理)\n\t\t\t* [调优方案](/post/《后端架构师技术图谱》#调优方案)\n\t\t* [Jetty](/post/《后端架构师技术图谱》#jetty)\n\t* [缓存](/post/《后端架构师技术图谱》#缓存)\n\t\t* [本地缓存](/post/《后端架构师技术图谱》#本地缓存)\n\t* [客户端缓存](/post/《后端架构师技术图谱》#客户端缓存)\n\t* [服务端缓存](/post/《后端架构师技术图谱》#服务端缓存)\n\t\t* [Web缓存](/post/《后端架构师技术图谱》#web缓存)\n\t\t* [Memcached](/post/《后端架构师技术图谱》#memcached)\n\t\t* [Redis](/post/《后端架构师技术图谱》#redis)\n\t\t\t* [架构](/post/《后端架构师技术图谱》#架构)\n\t\t\t* [回收策略](/post/《后端架构师技术图谱》#回收策略)\n\t\t* [Tair](/post/《后端架构师技术图谱》#tair)\n\t* [消息队列](/post/《后端架构师技术图谱》#消息队列)\n\t\t* [消息总线](/post/《后端架构师技术图谱》#消息总线)\n\t\t* [消息的顺序](/post/《后端架构师技术图谱》#消息的顺序)\n\t\t* [RabbitMQ](/post/《后端架构师技术图谱》#rabbitmq)\n\t\t* [RocketMQ](/post/《后端架构师技术图谱》#rocketmq)\n\t\t* [ActiveMQ](/post/《后端架构师技术图谱》#activemq)\n\t\t* [Kafka](/post/《后端架构师技术图谱》#kafka)\n\t\t* [Redis 消息推送](/post/《后端架构师技术图谱》#redis-消息推送)\n\t\t* [ZeroMQ](/post/《后端架构师技术图谱》#zeromq)\n\t* [定时调度](/post/《后端架构师技术图谱》#定时调度)\n\t\t* [单机定时调度](/post/《后端架构师技术图谱》#单机定时调度)\n\t\t* [分布式定时调度](/post/《后端架构师技术图谱》#分布式定时调度)\n\t* [RPC](/post/《后端架构师技术图谱》#rpc)\n\t\t* [Dubbo](/post/《后端架构师技术图谱》#dubbo)\n\t\t* [Thrift](/post/《后端架构师技术图谱》#thrift)\n\t\t* [gRPC](/post/《后端架构师技术图谱》#grpc)\n\t* [数据库中间件](/post/《后端架构师技术图谱》#数据库中间件)\n\t\t* [Sharding Jdbc](/post/《后端架构师技术图谱》#sharding-jdbc)\n\t* [日志系统](/post/《后端架构师技术图谱》#日志系统)\n\t\t* [日志搜集](/post/《后端架构师技术图谱》#日志搜集)\n\t* [配置中心](/post/《后端架构师技术图谱》#配置中心)\n\t* [API 网关](/post/《后端架构师技术图谱》#api-网关)\n* [网络](/post/《后端架构师技术图谱》#网络)\n\t* [协议](/post/《后端架构师技术图谱》#协议)\n\t\t* [OSI 七层协议](/post/《后端架构师技术图谱》#osi-七层协议)\n\t\t* [TCP/IP](/post/《后端架构师技术图谱》#tcpip)\n\t\t* [HTTP](/post/《后端架构师技术图谱》#http)\n\t\t* [HTTP2.0](/post/《后端架构师技术图谱》#http20)\n\t\t* [HTTPS](/post/《后端架构师技术图谱》#https)\n\t* [网络模型](/post/《后端架构师技术图谱》#网络模型)\n\t\t* [Epoll](/post/《后端架构师技术图谱》#epoll)\n\t\t* [Java NIO](/post/《后端架构师技术图谱》#java-nio)\n\t\t* [kqueue](/post/《后端架构师技术图谱》#kqueue)\n\t* [连接和短连接](/post/《后端架构师技术图谱》#连接和短连接)\n\t* [框架](/post/《后端架构师技术图谱》#框架)\n\t* [零拷贝（Zero-copy）](/post/《后端架构师技术图谱》#零拷贝zero-copy)\n\t* [序列化(二进制协议)](/post/《后端架构师技术图谱》#序列化二进制协议)\n\t\t* [Hessian](/post/《后端架构师技术图谱》#hessian)\n\t\t* [Protobuf](/post/《后端架构师技术图谱》#protobuf)\n* [数据库](/post/《后端架构师技术图谱》#数据库)\n\t* [基础理论](/post/《后端架构师技术图谱》#基础理论)\n\t\t* [数据库设计的三大范式](/post/《后端架构师技术图谱》#数据库设计的三大范式)\n\t* [MySQL](/post/《后端架构师技术图谱》#mysql)\n\t\t* [原理](/post/《后端架构师技术图谱》#原理)\n\t\t* [InnoDB](/post/《后端架构师技术图谱》#innodb)\n\t\t* [优化](/post/《后端架构师技术图谱》#优化)\n\t\t* [索引](/post/《后端架构师技术图谱》#索引)\n\t\t\t* [聚集索引, 非聚集索引](/post/《后端架构师技术图谱》#聚集索引-非聚集索引)\n\t\t\t* [复合索引](/post/《后端架构师技术图谱》#复合索引)\n\t\t\t* [自适应哈希索引(AHI)](/post/《后端架构师技术图谱》#自适应哈希索引ahi)\n\t\t* [explain](/post/《后端架构师技术图谱》#explain)\n\t* [NoSQL](/post/《后端架构师技术图谱》#nosql)\n\t\t* [MongoDB](/post/《后端架构师技术图谱》#mongodb)\n\t\t* [Hbase](/post/《后端架构师技术图谱》#hbase)\n* [搜索引擎](/post/《后端架构师技术图谱》#搜索引擎)\n\t* [搜索引擎原理](/post/《后端架构师技术图谱》#搜索引擎原理)\n\t* [Lucene](/post/《后端架构师技术图谱》#lucene)\n\t* [Elasticsearch](/post/《后端架构师技术图谱》#elasticsearch)\n\t* [Solr](/post/《后端架构师技术图谱》#solr)\n\t* [sphinx](/post/《后端架构师技术图谱》#sphinx)\n* [性能](/post/《后端架构师技术图谱》#性能)\n\t* [性能优化方法论](/post/《后端架构师技术图谱》#性能优化方法论)\n\t* [容量评估](/post/《后端架构师技术图谱》#容量评估)\n\t* [CDN 网络](/post/《后端架构师技术图谱》#cdn-网络)\n\t* [连接池](/post/《后端架构师技术图谱》#连接池)\n\t* [性能调优](/post/《后端架构师技术图谱》#性能调优)\n* [大数据](/post/《后端架构师技术图谱》#大数据)\n\t* [流式计算](/post/《后端架构师技术图谱》#流式计算)\n\t\t* [Storm](/post/《后端架构师技术图谱》#storm)\n\t\t* [Flink](/post/《后端架构师技术图谱》#flink)\n\t\t* [Kafka Stream](/post/《后端架构师技术图谱》#kafka-stream)\n\t\t* [应用场景](/post/《后端架构师技术图谱》#应用场景-1)\n\t* [Hadoop](/post/《后端架构师技术图谱》#hadoop)\n\t\t* [HDFS](/post/《后端架构师技术图谱》#hdfs)\n\t\t* [MapReduce](/post/《后端架构师技术图谱》#mapreduce)\n\t\t* [Yarn](/post/《后端架构师技术图谱》#yarn)\n\t* [Spark](/post/《后端架构师技术图谱》#spark)\n* [安全](/post/《后端架构师技术图谱》#安全)\n\t* [web 安全](/post/《后端架构师技术图谱》#web-安全)\n\t\t* [XSS](/post/《后端架构师技术图谱》#xss)\n\t\t* [CSRF](/post/《后端架构师技术图谱》#csrf)\n\t\t* [SQL 注入](/post/《后端架构师技术图谱》#sql-注入)\n\t\t* [Hash Dos](/post/《后端架构师技术图谱》#hash-dos)\n\t\t* [脚本注入](/post/《后端架构师技术图谱》#脚本注入)\n\t\t* [漏洞扫描工具](/post/《后端架构师技术图谱》#漏洞扫描工具)\n\t\t* [验证码](/post/《后端架构师技术图谱》#验证码)\n\t* [DDoS 防范](/post/《后端架构师技术图谱》#ddos-防范)\n\t* [用户隐私信息保护](/post/《后端架构师技术图谱》#用户隐私信息保护)\n\t* [序列化漏洞](/post/《后端架构师技术图谱》#序列化漏洞)\n\t* [加密解密](/post/《后端架构师技术图谱》#加密解密)\n\t\t* [对称加密](/post/《后端架构师技术图谱》#对称加密)\n\t\t* [哈希算法](/post/《后端架构师技术图谱》#哈希算法)\n\t\t* [非对称加密](/post/《后端架构师技术图谱》#非对称加密)\n\t* [服务器安全](/post/《后端架构师技术图谱》#服务器安全)\n\t* [数据安全](/post/《后端架构师技术图谱》#数据安全)\n\t\t* [数据备份](/post/《后端架构师技术图谱》#数据备份)\n\t* [网络隔离](/post/《后端架构师技术图谱》#网络隔离)\n\t\t* [内外网分离](/post/《后端架构师技术图谱》#内外网分离)\n\t\t* [登录跳板机](/post/《后端架构师技术图谱》#登录跳板机)\n\t* [授权、认证](/post/《后端架构师技术图谱》#授权认证)\n\t\t* [RBAC](/post/《后端架构师技术图谱》#rbac)\n\t\t* [OAuth2.0](/post/《后端架构师技术图谱》#oauth20)\n\t\t* [双因素认证（2FA）](/post/《后端架构师技术图谱》#双因素认证2fa)\n\t\t* [单点登录(SSO)](/post/《后端架构师技术图谱》#单点登录sso)\n* [常用开源框架](/post/《后端架构师技术图谱》#常用开源框架)\n\t* [开源协议](/post/《后端架构师技术图谱》#开源协议)\n\t* [日志框架](/post/《后端架构师技术图谱》#日志框架)\n\t\t* [Log4j、Log4j2](/post/《后端架构师技术图谱》#log4jlog4j2)\n\t\t* [Logback](/post/《后端架构师技术图谱》#logback)\n\t* [ORM](/post/《后端架构师技术图谱》#orm)\n\t* [网络框架](/post/《后端架构师技术图谱》#网络框架)\n\t* [Web 框架](/post/《后端架构师技术图谱》#web-框架)\n\t\t* [Spring 家族](/post/《后端架构师技术图谱》#spring-家族)\n\t* [工具框架](/post/《后端架构师技术图谱》#工具框架)\n* [分布式设计](/post/《后端架构师技术图谱》#分布式设计)\n\t* [扩展性设计](/post/《后端架构师技术图谱》#扩展性设计)\n\t* [稳定性 &amp; 高可用](/post/《后端架构师技术图谱》#稳定性--高可用)\n\t\t* [硬件负载均衡](/post/《后端架构师技术图谱》#硬件负载均衡)\n\t\t* [软件负载均衡](/post/《后端架构师技术图谱》#软件负载均衡)\n\t\t* [限流](/post/《后端架构师技术图谱》#限流)\n\t\t* [应用层容灾](/post/《后端架构师技术图谱》#应用层容灾)\n\t\t* [跨机房容灾](/post/《后端架构师技术图谱》#跨机房容灾)\n\t\t* [容灾演练流程](/post/《后端架构师技术图谱》#容灾演练流程)\n\t\t* [平滑启动](/post/《后端架构师技术图谱》#平滑启动)\n\t* [数据库扩展](/post/《后端架构师技术图谱》#数据库扩展)\n\t\t* [读写分离模式](/post/《后端架构师技术图谱》#读写分离模式)\n\t\t* [分片模式](/post/《后端架构师技术图谱》#分片模式)\n\t* [服务治理](/post/《后端架构师技术图谱》#服务治理)\n\t\t* [服务注册与发现](/post/《后端架构师技术图谱》#服务注册与发现)\n\t\t* [服务路由控制](/post/《后端架构师技术图谱》#服务路由控制)\n\t* [分布式一致](/post/《后端架构师技术图谱》#分布式一致)\n\t\t* [CAP 与 BASE 理论](/post/《后端架构师技术图谱》#cap-与-base-理论)\n\t\t* [分布式锁](/post/《后端架构师技术图谱》#分布式锁)\n\t\t* [分布式一致性算法](/post/《后端架构师技术图谱》#分布式一致性算法)\n\t\t\t* [PAXOS](/post/《后端架构师技术图谱》#paxos)\n\t\t\t* [Zab](/post/《后端架构师技术图谱》#zab)\n\t\t\t* [Raft](/post/《后端架构师技术图谱》#raft)\n\t\t\t* [Gossip](/post/《后端架构师技术图谱》#gossip)\n\t\t\t* [两阶段提交、多阶段提交](/post/《后端架构师技术图谱》#两阶段提交多阶段提交)\n\t\t* [幂等](/post/《后端架构师技术图谱》#幂等)\n\t\t* [分布式一致方案](/post/《后端架构师技术图谱》#分布式一致方案)\n\t\t* [分布式 Leader 节点选举](/post/《后端架构师技术图谱》#分布式-leader-节点选举)\n\t\t* [TCC(Try/Confirm/Cancel) 柔性事务](/post/《后端架构师技术图谱》#tcctryconfirmcancel-柔性事务)\n\t* [分布式文件系统](/post/《后端架构师技术图谱》#分布式文件系统)\n\t* [唯一ID 生成](/post/《后端架构师技术图谱》#唯一id-生成)\n\t\t* [全局唯一ID](/post/《后端架构师技术图谱》#全局唯一id)\n\t* [一致性Hash算法](/post/《后端架构师技术图谱》#一致性hash算法)\n* [设计思想 &amp; 开发模式](/post/《后端架构师技术图谱》#设计思想--开发模式)\n\t* [DDD(Domain-driven Design - 领域驱动设计)](/post/《后端架构师技术图谱》#ddddomain-driven-design---领域驱动设计)\n\t\t* [命令查询职责分离(CQRS)](/post/《后端架构师技术图谱》#命令查询职责分离cqrs)\n\t\t* [贫血，充血模型](/post/《后端架构师技术图谱》#贫血充血模型)\n\t* [Actor 模式](/post/《后端架构师技术图谱》#actor-模式)\n\t* [响应式编程](/post/《后端架构师技术图谱》#响应式编程)\n\t\t* [Reactor](/post/《后端架构师技术图谱》#reactor)\n\t\t* [RxJava](/post/《后端架构师技术图谱》#rxjava)\n\t\t* [Vert.x](/post/《后端架构师技术图谱》#vertx)\n\t* [DODAF2.0](/post/《后端架构师技术图谱》#dodaf20)\n\t* [Serverless](/post/《后端架构师技术图谱》#serverless)\n\t* [Service Mesh](/post/《后端架构师技术图谱》#service-mesh)\n* [项目管理](/post/《后端架构师技术图谱》#项目管理)\n\t* [架构评审](/post/《后端架构师技术图谱》#架构评审)\n\t* [重构](/post/《后端架构师技术图谱》#重构)\n\t* [代码规范](/post/《后端架构师技术图谱》#代码规范)\n\t* [代码 Review](/post/《后端架构师技术图谱》#代码-review)\n\t* [RUP](/post/《后端架构师技术图谱》#rup)\n\t* [看板管理](/post/《后端架构师技术图谱》#看板管理)\n\t* [SCRUM](/post/《后端架构师技术图谱》#scrum)\n\t* [敏捷开发](/post/《后端架构师技术图谱》#敏捷开发)\n\t* [极限编程（XP）](/post/《后端架构师技术图谱》#极限编程xp)\n\t* [结对编程](/post/《后端架构师技术图谱》#结对编程)\n\t* [PDCA 循环质量管理](/post/《后端架构师技术图谱》#pdca-循环质量管理)\n\t* [FMEA管理模式](/post/《后端架构师技术图谱》#fmea管理模式)\n* [通用业务术语](/post/《后端架构师技术图谱》#通用业务术语)\n* [技术趋势](/post/《后端架构师技术图谱》#技术趋势)\n* [政策、法规](/post/《后端架构师技术图谱》#政策法规)\n\t* [法律](/post/《后端架构师技术图谱》#法律)\n\t\t* [严格遵守刑法253法条](/post/《后端架构师技术图谱》#严格遵守刑法253法条)\n* [架构师素质](/post/《后端架构师技术图谱》#架构师素质)\n* [团队管理](/post/《后端架构师技术图谱》#团队管理)\n\t* [招聘](/post/《后端架构师技术图谱》#招聘)\n* [资讯](/post/《后端架构师技术图谱》#资讯)\n\t* [行业资讯](/post/《后端架构师技术图谱》#行业资讯)\n\t* [公众号列表](/post/《后端架构师技术图谱》#公众号列表)\n\t* [博客](/post/《后端架构师技术图谱》#博客)\n\t\t* [团队博客](/post/《后端架构师技术图谱》#团队博客)\n\t\t* [个人博客](/post/《后端架构师技术图谱》#个人博客)\n\t* [综合门户、社区](/post/《后端架构师技术图谱》#综合门户社区)\n\t* [问答、讨论类社区](/post/《后端架构师技术图谱》#问答讨论类社区)\n\t* [行业数据分析](/post/《后端架构师技术图谱》#行业数据分析)\n\t* [专项网站](/post/《后端架构师技术图谱》#专项网站)\n\t* [其他类](/post/《后端架构师技术图谱》#其他类)\n\t* [推荐参考书](/post/《后端架构师技术图谱》#推荐参考书)\n\t\t* [在线电子书](/post/《后端架构师技术图谱》#在线电子书)\n\t\t* [纸质书](/post/《后端架构师技术图谱》#纸质书)\n\t\t\t* [开发方面](/post/《后端架构师技术图谱》#开发方面)\n\t\t\t* [架构方面](/post/《后端架构师技术图谱》#架构方面)\n\t\t\t* [技术管理方面](/post/《后端架构师技术图谱》#技术管理方面)\n\t\t\t* [基础理论](/post/《后端架构师技术图谱》#基础理论-1)\n\t\t\t* [工具方面](/post/《后端架构师技术图谱》#工具方面)\n\t\t\t* [大数据方面](/post/《后端架构师技术图谱》#大数据方面)\n* [技术资源](/post/《后端架构师技术图谱》#技术资源)\n\t* [开源资源](/post/《后端架构师技术图谱》#开源资源)\n\t* [手册、文档、教程](/post/《后端架构师技术图谱》#手册文档教程)\n\t* [在线课堂](/post/《后端架构师技术图谱》#在线课堂)\n\t* [会议、活动](/post/《后端架构师技术图谱》#会议活动)\n\t* [常用APP](/post/《后端架构师技术图谱》#常用app)\n\t* [找工作](/post/《后端架构师技术图谱》#找工作)\n\t* [工具](/post/《后端架构师技术图谱》#工具)\n\t* [代码托管](/post/《后端架构师技术图谱》#代码托管)\n\t* [文件服务](/post/《后端架构师技术图谱》#文件服务)\n\t* [综合云服务商](/post/《后端架构师技术图谱》#综合云服务商)\n\t\t* [VPS](/post/《后端架构师技术图谱》#vps)\n\t\n\n**（Toc generated by [simple-php-github-toc](https://github.com/xingshaocheng/simple-php-github-toc) ）**\n\n# 数据结构\n\n## 队列\n* [《java队列——queue详细分析》](https://www.cnblogs.com/lemon-flm/p/7877898.html)\n\t* 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。\n\t* 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。\n\n* [《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》](https://www.cnblogs.com/mantu/p/5802393.html)\n\n## 集合\n* [《Java Set集合的详解》](https://blog.csdn.net/qq_33642117/article/details/52040345)\n\n## 链表、数组\n* [《Java集合详解--什么是List》](https://blog.csdn.net/wz249863091/article/details/52853360)\n\n## 字典、关联数组\n* [《Java map 详解 - 用法、遍历、排序、常用API等》](https://baike.xsoftlab.net/view/250.html)\n\n## 栈\n* [《java数据结构与算法之栈（Stack）设计与实现》](https://blog.csdn.net/javazejian/article/details/53362993)\n* [《Java Stack 类》](http://www.runoob.com/java/java-stack-class.html)\n* [《java stack的详细实现分析》](https://blog.csdn.net/f2006116/article/details/51375225)\n\t* Stack 是线程安全的。\n\t* 内部使用数组保存数据，不够时翻倍。\n\n## 树\n\n### 二叉树\n\n每个节点最多有两个叶子节点。\n*  [《二叉树》](https://blog.csdn.net/cai2016/article/details/52589952)\n\n### 完全二叉树\n* [《完全二叉树》](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)\n\t* 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。\n\n### 平衡二叉树\n左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n* [《浅谈数据结构-平衡二叉树》](http://www.cnblogs.com/polly333/p/4798944.html)\n* [《浅谈算法和数据结构: 八 平衡查找树之2-3树》](http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)\n\n### 二叉查找树（BST）\n二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。\n\n* [《浅谈算法和数据结构: 七 二叉查找树》](http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html)\n\n\n### 红黑树\n* [《最容易懂得红黑树》](https://blog.csdn.net/sun_tttt/article/details/65445754)\n\t* 添加阶段后，左旋或者右旋从而再次达到平衡。 \n* [《浅谈算法和数据结构: 九 平衡查找树之红黑树》](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)\n\n### B-，B+，B*树\nMySQL是基于B+树聚集索引组织表\n\n* [《B-树，B+树，B\\*树详解》](https://blog.csdn.net/aqzwss/article/details/53074186)\n* [《B-树，B+树与B\\*树的优缺点比较》](https://blog.csdn.net/bigtree_3721/article/details/73632405)\n\t* B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。\n### LSM 树\n\nLSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。\nHbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。\n\n* [《LSM树 VS B+树》](https://blog.csdn.net/dbanote/article/details/8897599)\n\t* B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。\n\t* LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。\n\t\n* [《LSM树（Log-Structured Merge Tree）存储引擎》](https://blog.csdn.net/u014774781/article/details/52105708)\n\t* 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。\n\t* 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。\n\t* Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。\n\n## BitSet\n\n经常用于大规模数据的排重检查。\n\n* [《Java Bitset类》](http://www.runoob.com/java/java-bitset-class.html)\n* [《Java BitSet（位集）》](https://blog.csdn.net/caiandyong/article/details/51581160)\n\n# 常用算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n## 排序、查找算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n### 选择排序\n* [《Java中的经典算法之选择排序（SelectionSort）》](https://www.cnblogs.com/shen-hua/p/5424059.html)\n\t* 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。\n\n### 冒泡排序\n* [《冒泡排序的2种写法》](https://blog.csdn.net/shuaizai88/article/details/73250615)\n\t* 相邻元素前后交换、把最大的排到最后。\n\t* 时间复杂度 O(n²) \n\n### 插入排序\n* [《排序算法总结之插入排序》](https://www.cnblogs.com/hapjin/p/5517667.html)\n\n### 快速排序\n* [《坐在马桶上看算法：快速排序》](http://developer.51cto.com/art/201403/430986.htm)\n\t* 一侧比另外一次都大或小。 \n### 归并排序\n* [《图解排序算法(四)之归并排序》](http://www.cnblogs.com/chengxiao/p/6194356.html)\n\t* 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 \n\n### 希尔排序\nTODO\n\n### 堆排序\n* [《图解排序算法(三)之堆排序》](https://www.cnblogs.com/chengxiao/p/6129630.html)\n\t* 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。\n\n### 计数排序\n* [《计数排序和桶排序》](https://www.cnblogs.com/suvllian/p/5495780.html)\n\t* 和桶排序过程比较像，差别在于桶的数量。\n\n### 桶排序\n* [《【啊哈！算法】最快最简单的排序——桶排序》](http://blog.51cto.com/ahalei/1362789)\n* [《排序算法（三）：计数排序与桶排序》](https://blog.csdn.net/sunjinshengli/article/details/70738527)\n\t* 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。\n\t* 每个桶单独进行排序，然后再遍历每个桶。\n\n### 基数排序\n\n按照个位、十位、百位、...依次来排。\n\n* [《排序算法系列：基数排序》](https://blog.csdn.net/lemon_tree12138/article/details/51695211)\n* [《基数排序》](https://www.cnblogs.com/skywang12345/p/3603669.html)\n\n\n### 二分查找\n* [《二分查找(java实现)》](https://www.cnblogs.com/coderising/p/5708632.html)\n\t* 要求待查找的序列有序。\n\t* 时间复杂度 O(logN)。\n\n* [《java实现二分查找-两种方式》](https://blog.csdn.net/maoyuanming0806/article/details/78176957)\n\t* while + 递归。\n### Java 中的排序工具\n* [《Arrays.sort和Collections.sort实现原理解析》](https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1)\n\t* Collections.sort算法调用的是合并排序。\n\t* Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。\n\n## 布隆过滤器\n\n常用于大数据的排重，比如email，url 等。\n核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。\n优点：空间和时间效率都很高。\n缺点：随着存入的元素数量增加，误算率随之增加。\n\n* [《布隆过滤器 -- 空间效率很高的数据结构》](https://segmentfault.com/a/1190000002729689)\n* [《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》](https://blog.csdn.net/zdxiq000/article/details/57626464)\n* [《基于Redis的布隆过滤器的实现》](https://blog.csdn.net/qq_30242609/article/details/71024458)\n\t* 基于 Redis 的 Bitmap 数据结构。\n* [《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》](https://blog.csdn.net/lemon_tree12138/article/details/47973715)\n\t* 使用Java中的 BitSet 类 和 加权和hash算法。\n\n## 字符串比较\n\n### KMP 算法\nKMP：Knuth-Morris-Pratt算法（简称KMP）\n核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。\n* [《字符串匹配的KMP算法》](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)\n\n## 深度优先、广度优先\n* [《广度优先搜索BFS和深度优先搜索DFS》](https://www.cnblogs.com/0kk470/p/7555033.html)\n\n## 贪心算法\n* [《算法：贪婪算法基础》](https://www.cnblogs.com/MrSaver/p/8641971.html)\n* [《常见算法及问题场景——贪心算法》](https://blog.csdn.net/a345017062/article/details/52443781)\n\n## 回溯算法\n* [《 五大常用算法之四：回溯法》](https://blog.csdn.net/qfikh/article/details/51960331)\n\n## 剪枝算法\n* [《α-β剪枝算法》](https://blog.csdn.net/luningcsdn/article/details/50930276)\n\n## 动态规划\n* [《详解动态规划——邹博讲动态规划》](https://www.cnblogs.com/little-YTMM/p/5372680.html)\n* [《动态规划算法的个人理解》](https://blog.csdn.net/yao_zi_jie/article/details/54580283)\n\n## 朴素贝叶斯\n\n* [《带你搞懂朴素贝叶斯分类算法》](https://blog.csdn.net/amds123/article/details/70173402)\n\t* P(B|A)=P(A|B)P(B)/P(A)\n\n* [《贝叶斯推断及其互联网应用1》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html)\n* [《贝叶斯推断及其互联网应用2》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html)\n\n\n## 推荐算法\n* [《推荐算法综述》](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)\n* [《TOP 10 开源的推荐系统简介》](https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems)\n\n## 最小生成树算法\n* [《算法导论--最小生成树（Kruskal和Prim算法）》](https://blog.csdn.net/luoshixian099/article/details/51908175)\n\n## 最短路径算法\n\n* [《Dijkstra算法详解》](https://blog.csdn.net/qq_35644234/article/details/60870719)\n\n# 并发\n\n## Java 并发\n\n* [Java 并发知识合集](https://github.com/CL0610/Java-concurrency)\n* [JAVA并发知识图谱](https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png)\n\n## 多线程\n\n* [《40个Java多线程问题总结》](http://www.importnew.com/18459.html)\n\n## 线程安全\n\n* [《Java并发编程——线程安全及解决机制简介》](https://www.cnblogs.com/zhanht/p/5450325.html)\n\n## 一致性、事务\n\n### 事务 ACID 特性\n* [《数据库事务ACID特性》](https://blog.csdn.net/u012440687/article/details/52116108)\n\n### 事务的隔离级别\n\n* 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。\n* 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。\n* 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。\n* 序列化：所有事物串行处理（牺牲了效率）\n\n* [《理解事务的4种隔离级别》](https://blog.csdn.net/qq_33290787/article/details/51924963)\n* [数据库事务的四大特性及事务隔离级别](https://www.cnblogs.com/z-sm/p/7245981.html)\n\n* [《MySQL的InnoDB的幻读问题 》](http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html)\n\t* 幻读的例子非常清楚。\n\t* 通过 SELECT ... FOR UPDATE 解决。\n\t\n* [《一篇文章带你读懂MySQL和InnoDB》](http://database.51cto.com/art/201804/570101.htm)\n\t* 图解脏读、不可重复读、幻读问题。\n\n\n### MVCC\n\n\n* [《【mysql】关于innodb中MVCC的一些理解》](https://www.cnblogs.com/chenpingzhao/p/5065316.html)\n\t* innodb 中 MVCC 用在 Repeatable-Read 隔离级别。\n\t* MVCC 会产生幻读问题（更新时异常。）\n\n* [《轻松理解MYSQL MVCC 实现机制》](https://blog.csdn.net/whoamiyang/article/details/51901888)\n\n\t* 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间\n\t* 每次只操作比当前版本小（或等于）的 行。\n\t\n\n\n## 锁\n\n### Java中的锁和同步类\n\n* [《Java中的锁分类》](https://www.cnblogs.com/qifengshi/p/6831055.html)\n\t* 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 \n\n* [《Java并发之AQS详解》](https://www.cnblogs.com/waterystone/p/4920797.html)\n\n* [《Java中信号量 Semaphore》](http://cuisuqiang.iteye.com/blog/2020146)\n\t* 有数量控制\n\t* 申请用 acquire，申请不要则阻塞；释放用 release。\n\n* [《java开发中的Mutex vs Semaphore》](https://www.cnblogs.com/davidwang456/p/6094947.html)\n\t* 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。\t \n\n### 公平锁 & 非公平锁\n\n公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。\n\n* [《公平锁与非公平锁》](https://blog.csdn.net/EthanWhite/article/details/55508357)\n\t* 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。\n\n### 悲观锁 \n\n悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。\n\n* [《【MySQL】悲观锁&乐观锁》](https://www.cnblogs.com/zhiqian-ali/p/6200874.html)\n\t* 乐观锁的方式：版本号+重试方式\n\t* 悲观锁：通过 select ... for update 进行行锁(不可读、不可写，share 锁可读不可写)。\n\n* [《Mysql查询语句使用select.. for update导致的数据库死锁分析》](https://www.cnblogs.com/Lawson/p/5008741.html)\n\t* mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。\n\t* 锁相同数据的不同索引条件可能会引起死锁。\n\t\n* [《Mysql并发时经典常见的死锁原因及解决方法》](https://www.cnblogs.com/zejin2008/p/5262751.html)\n\n### 乐观锁 & CAS\n\n* [《乐观锁的一种实现方式——CAS》](http://www.importnew.com/20472.html)\n\t* 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。\t \n\n### ABA 问题\n\n由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。\n\n* [《Java CAS 和ABA问题》](https://www.cnblogs.com/549294286/p/3766717.html)\n* [《Java 中 ABA问题及避免》](https://blog.csdn.net/li954644351/article/details/50511879)\n\t* AtomicStampedReference 和 AtomicStampedReference。 \n\n### CopyOnWrite容器\n\n可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。\n\n* [《JAVA中写时复制(Copy-On-Write)Map实现》](https://www.cnblogs.com/hapjin/p/4840107.html)\n\t* 实现读写分离，读取发生在原始数据上，写入发生在副本上。  \n\t* 不用加锁，通过最终一致实现一致性。\n\t\n* [《聊聊并发-Java中的Copy-On-Write容器》](https://blog.csdn.net/a494303877/article/details/53404623)\n\n### RingBuffer \n* [《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》](http://www.cnblogs.com/l00l/p/4115001.html)\n\n### 可重入锁 & 不可重入锁\n\n* [《可重入锁和不可重入锁》](https://www.cnblogs.com/dj3839/p/6580765.html)\n\t* 通过简单代码举例说明可重入锁和不可重入锁。\n\t* 可重入锁指同一个线程可以再次获得之前已经获得的锁。\n\t* 可重入锁可以用户避免死锁。\n\t* Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock\n\n* [《ReenTrantLock可重入锁（和synchronized的区别）总结》](https://www.cnblogs.com/baizhanshi/p/7211802.html)\n\t* synchronized 使用方便，编译器来加锁，是非公平锁。\n\t* ReenTrantLock 使用灵活，锁的公平性可以定制。\n\t* 相同加锁场景下，推荐使用 synchronized。\n\n### 互斥锁 & 共享锁\n\n互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。\n共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。\n\n* [《ReadWriteLock场景应用》](https://www.cnblogs.com/liang1101/p/6475555.html)\n\n### 死锁\n* [《“死锁”四个必要条件的合理解释》](https://blog.csdn.net/yunfenglw/article/details/45950305)\n\t* 互斥、持有、不可剥夺、环形等待。\n* [Java如何查看死锁？](https://blog.csdn.net/u014039577/article/details/52351626)\n\t* JConsole 可以识别死锁。\n\t\n* [java多线程系列：死锁及检测](https://blog.csdn.net/bohu83/article/details/51135061)\n\t* jstack 可以显示死锁。\n\t\n# 操作系统\n\n## 计算机原理\n\n* [《操作系统基础知识——操作系统的原理，类型和结构》](https://segmentfault.com/a/1190000003692840)\n\n## CPU\n\n### 多级缓存\n典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。\n\n* [《从Java视角理解CPU缓存和伪共享》](https://blog.csdn.net/zero__007/article/details/54089730)\n\n## 进程\n\nTODO\n\n## 线程\n\n* [《线程的生命周期及状态转换详解》](https://blog.csdn.net/asdf_1024/article/details/78978437)\n\n## 协程\n\n* [《终结python协程----从yield到actor模型的实现》](https://www.thinksaas.cn/group/topic/839375/)\n\t* 线程的调度是由操作系统负责，协程调度是程序自行负责\n\t* 与线程相比，协程减少了无谓的操作系统切换.\n\t* 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.\n\t\n## Linux\n\n* [《Linux 命令大全》](http://www.runoob.com/linux/linux-command-manual.html)\n\n# 设计模式\n\n## 设计模式的六大原则\n* [《设计模式的六大原则》](https://blog.csdn.net/q291611265/article/details/48465113)\n\t* 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。\n\t* 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。\n\t* 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。\n\t* 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。\n\t* 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。\n\t* 合成复用原则：尽量使用合成/聚合,而不是使用继承。\n\n## 23种常见设计模式\n* [《设计模式》](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)\n* [《23种设计模式全解析》](https://www.cnblogs.com/susanws/p/5510229.html)\n* [《设计模式类图与示例》](https://github.com/ToryZhou/design-pattern)\n\n## 应用场景\n* [《细数JDK里的设计模式》](http://blog.jobbole.com/62314/)\n\t* 结构型模式：\n\t\t* 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。\n\t\t* 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；\n\t\t* 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。\n\t\t* 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。\n\t\t* 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。\n\t\t* 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy\n\t\t\n\t* 创建模式:\n\t\t* 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。\n\t\t* 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。\n\t\t* 工厂方法：就是 **一个返*** 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。\n\t\t* 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。\n\t\t* 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。\n\t* 行为模式：\n\t\t* 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。\n\t\t* 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。\n\t\t* 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。\n\t\t* 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。\n\t\t* 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。\n\t\t* 空对象模式：如 java.util.Collections#emptyList()。\n\t\t* 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。\n\t\t* 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。\n\n* [《Spring-涉及到的设计模式汇总》](https://www.cnblogs.com/hwaggLee/p/4510687.html)\n* [《Mybatis使用的设计模式》](https://blog.csdn.net/u012387062/article/details/54719114)\n\n## 单例模式\n* [《单例模式的三种实现 以及各自的优缺点》](https://blog.csdn.net/YECrazy/article/details/79481964)\n* [《单例模式－－反射－－防止序列化破坏单例模式》](https://www.cnblogs.com/ttylinux/p/6498822.html)\n\t* 使用枚举类型。\n\n## 责任链模式\nTODO\n\n## MVC\n* [《MVC 模式》](http://www.runoob.com/design-pattern/mvc-pattern.html)\n\t* 模型(model)－视图(view)－控制器(controller) \n\n## IOC\n* [《理解 IOC》](https://www.zhihu.com/question/23277575)\n* [《IOC 的理解与解释》](https://www.cnblogs.com/NancyStartOnce/p/6813162.html)\n\t* 正向控制：传统通过new的方式。反向控制，通过容器注入对象。\n\t* 作用：用于模块解耦。\n\t* DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。\n\n## AOP\n\n* [《轻松理解AOP(面向切面编程)》](https://blog.csdn.net/yanquan345/article/details/19760027)\n* [《Spring AOP详解》](https://www.cnblogs.com/hongwz/p/5764917.html)\n* [《Spring AOP的实现原理》](http://www.importnew.com/24305.html)\n\t* Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。\n* [《Spring AOP 实现原理与 CGLIB 应用》](https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/)\n\t* Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 \n\n\n## UML\n\n* [《UML教程》](https://www.w3cschool.cn/uml_tutorial/)\n\n## 微服务思想\n* [《微服务架构设计》](https://www.cnblogs.com/wintersun/p/6219259.html)\n* [《微服务架构技术栈选型手册》](http://www.infoq.com/cn/articles/micro-service-technology-stack)\n\n### 康威定律\n* [《微服务架构的理论基础 - 康威定律》](https://yq.aliyun.com/articles/8611)\n\t* 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。\n\t* 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。\n\t* 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。\n\t* 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。\n\n* [《微服务架构核⼼20讲》](https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf)\n\n# 运维 & 统计 & 技术支持 \n\n## 常规监控\n\n* [《腾讯业务系统监控的修炼之路》](https://blog.csdn.net/enweitech/article/details/77849205)\n\t* 监控的方式：主动、被动、旁路(比如舆情监控)\n\t* 监控类型： 基础监控、服务端监控、客户端监控、\n\t监控、用户端监控\n\t* 监控的目标：全、块、准\n\t* 核心指标：请求量、成功率、耗时\n\n* [《开源还是商用？十大云运维监控工具横评》](https://www.oschina.net/news/67525/monitoring-tools)\n\t* Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。\n\n* [《监控报警系统搭建及二次开发经验》](http://developer.51cto.com/art/201612/525373.htm)\n\n**命令行监控工具**\n\n* [《常用命令行监控工具》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html)\n\t* top、sar、tsar、nload\n\n* [《20个命令行工具监控 Linux 系统性能》](http://blog.jobbole.com/96846/)\n\n* [《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》](https://my.oschina.net/feichexia/blog/196575)\n\n## APM\n\nAPM —  Application Performance Management\n\n* [《Dapper，大规模分布式系统的跟踪系统》](http://bigbully.github.io/Dapper-translation/)\n\n* [CNCF OpenTracing](http://opentracing.io)，[中文版](https://github.com/opentracing-contrib/opentracing-specification-zh)\n\n* 主要开源软件，按字母排序\n  * [Apache SkyWalking](https://github.com/apache/incubator-skywalking)\n  * [CAT](https://github.com/dianping/cat)\n  * [CNCF jaeger](https://github.com/jaegertracing/jaeger)\n  * [Pinpoint](https://github.com/naver/pinpoint)\n  * [Zipkin](https://github.com/openzipkin/zipkin)\n\n* [《开源APM技术选型与实战》](http://www.infoq.com/cn/articles/apm-Pinpoint-practice)\n\t* 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。\n\t\n\n\n## 统计分析\n\n* [《流量统计的基础：埋点》](https://zhuanlan.zhihu.com/p/25195217)\n\t* 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度\n\n* [《APP埋点常用的统计工具、埋点目标和埋点内容》](http://www.25xt.com/company/17066.html)\n\t* 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。\n\n* [《美团点评前端无痕埋点实践》](https://tech.meituan.com/mt-mobile-analytics-practice.html)\n\t* 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 \n\n\n## 持续集成(CI/CD)\n\n* [《持续集成是什么？》](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)\n* [《8个流行的持续集成工具》](https://www.testwo.com/article/1170)\n\n### Jenkins\n\n* [《使用Jenkins进行持续集成》](https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000)\n\n### 环境分离\n\n开发、测试、生成环境分离。\n\n* [《开发环境、生产环境、测试环境的基本理解和区》](https://my.oschina.net/sancuo/blog/214904)\n\n## 自动化运维\n\n### Ansible\n* [《Ansible中文权威指南》](http://www.ansible.com.cn/)\n* [《Ansible基础配置和企业级项目实用案例》](https://www.cnblogs.com/heiye123/articles/7855890.html)\n\n### puppet\n* [《自动化运维工具——puppet详解》](https://www.cnblogs.com/keerya/p/8040071.html)\n\n### chef\n* [《Chef 的安装与使用》](https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/)\n\n## 测试\n\n### TDD 理论\n\n* [《深度解读 - TDD（测试驱动开发）》](https://www.jianshu.com/p/62f16cd4fef3)\n\t* 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.\n\t* 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； \n\n### 单元测试\n\n* [《Java单元测试之JUnit篇》](https://www.cnblogs.com/happyzm/p/6482886.html)\n* [《JUnit 4 与 TestNG 对比》](https://blog.csdn.net/hotdust/article/details/53406086)\n\t* TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 \n* [《单元测试主要的测试功能点》](https://blog.csdn.net/wqetfg/article/details/50900512)\n\t* 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 \n\n### 压力测试\n\n* [《Apache ab 测试使用指南》](https://blog.csdn.net/blueheart20/article/details/52170790)\n* [《大型网站压力测试及优化方案》](https://www.cnblogs.com/binyue/p/6141088.html)\n* [《10大主流压力/负载/性能测试工具推荐》](http://news.chinabyte.com/466/14126966.shtml)\n* [《真实流量压测工具 tcpcopy应用浅析》](http://quentinxxz.iteye.com/blog/2249799)\n* [《nGrinder 简易使用教程》](https://www.cnblogs.com/jwentest/p/7136727.html)\n\n\n### 全链路压测\n* [《京东618：升级全链路压测方案，打造军演机器人ForceBot》](http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot)\n* [《饿了么全链路压测的探索与实践》](https://zhuanlan.zhihu.com/p/30306892)\n* [《四大语言，八大框架｜滴滴全链路压测解决之道》](https://zhuanlan.zhihu.com/p/28355759)\n* [《全链路压测经验》](https://www.jianshu.com/p/27060fd61f72)\n\n\n### A/B 、灰度、蓝绿测试\n\n* [《技术干货 | AB 测试和灰度发布探索及实践》](https://testerhome.com/topics/11165)\n* [《nginx 根据IP 进行灰度发布》](http://blog.51cto.com/purplegrape/1403123)\n\n* [《蓝绿部署、A/B 测试以及灰度发布》](https://www.v2ex.com/t/344341)\n\n## 虚拟化\n\n* [《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》](https://blog.csdn.net/enweitech/article/details/52910082)\n\n### KVM\n* [《KVM详解，太详细太深入了，经典》](http://blog.chinaunix.net/uid-20201831-id-5775661.html)\n* [《【图文】KVM 虚拟机安装详解》](https://www.coderxing.com/kvm-install.html)\n\n### Xen\n* [《Xen虚拟化基本原理详解》](https://www.cnblogs.com/sddai/p/5931201.html)\n\n### OpenVZ\n* [《开源Linux容器 OpenVZ 快速上手指南》](https://blog.csdn.net/longerzone/article/details/44829255)\n\n## 容器技术\n\n### Docker\n* [《几张图帮你理解 docker 基本原理及快速入门》](https://www.cnblogs.com/SzeCheng/p/6822905.html)\n* [《Docker 核心技术与实现原理》](https://draveness.me/docker)\n* [《Docker 教程》](http://www.runoob.com/docker/docker-tutorial.html)\n\n## 云技术\n\n### OpenStack\n* [《OpenStack构架知识梳理》](https://www.cnblogs.com/klb561/p/8660264.html)\n\n## DevOps\n* [《一分钟告诉你究竟DevOps是什么鬼？》](https://www.cnblogs.com/jetzhang/p/6068773.html)\n* [《DevOps详解》](http://www.infoq.com/cn/articles/detail-analysis-of-devops)\n\n## 文档管理\n\n* [Confluence-收费文档管理系统](http://www.confluence.cn/)\n* GitLab?\n* Wiki\n\n# 中间件\n\n## Web Server\n\n### Nginx\n* [《Ngnix的基本学习-多进程和Apache的比较》](https://blog.csdn.net/qq_25797077/article/details/52200722)\n\t* Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。\n\t* 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  \n\n* [《nginx与Apache的对比以及优缺点》](https://www.cnblogs.com/cunkouzh/p/5410154.html)\n\t* nginx只适合静态和反向代理，不适合处理动态请求。\n\n### OpenResty\n* [官方网站](http://openresty.org/cn/)\n* [《浅谈 OpenResty》](http://www.linkedkeeper.com/detail/blog.action?bid=1034)\n\t* 通过 Lua 模块可以在Nginx上进行开发。   \n* [agentzh 的 Nginx 教程](https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html)  \n\t\n### Tengine\n* [官方网站](http://tengine.taobao.org/)  \n\n### Apache Httpd\n* [官方网站](http://httpd.apache.org/)\n\n### Tomcat\n\n#### 架构原理\n* [《TOMCAT原理详解及请求过程》](https://www.cnblogs.com/hggen/p/6264475.html)\n* [《Tomcat服务器原理详解》](https://www.cnblogs.com/crazylqy/p/4706223.html)\n* [《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》](https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/)\n\n* [《四张图带你了解Tomcat系统架构》](https://blog.csdn.net/xlgen157387/article/details/79006434)\n\n* [《JBoss vs. Tomcat: Choosing A Java Application Server》](https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/)\n\t* Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。\n\t* Jboss 实现全部了JEE特性，软件开源免费、文档收费。\n\n#### 调优方案\n\n* [《Tomcat 调优方案》](https://www.cnblogs.com/sunfenqing/p/7339058.html)\n\t* 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； \n\n* [《tomcat http协议与ajp协议》](http://blog.chinaunix.net/uid-20662363-id-3012760.html)\n* [《AJP与HTTP比较和分析》](http://dmouse.iteye.com/blog/1354527)\n\t* AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。\n\t* 并发高时，AJP协议优于HTTP协议。\n\n### Jetty\n* [《Jetty 的工作原理以及与 Tomcat 的比较》](https://www.ibm.com/developerworks/cn/java/j-lo-jetty/)\n* [《jetty和tomcat优势比较》](https://blog.csdn.net/doutao6677/article/details/51957288)\n\t* 架构比较:Jetty的架构比Tomcat的更为简单。\n\t* 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。\n\t* 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 \n\n\n\n## 缓存\n\n* [《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》](https://blog.csdn.net/clementad/article/details/48229243)\n\n### 本地缓存\n\n* [《HashMap本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html)\n\n* [《EhCache本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html)\n\t* 堆内、堆外、磁盘三级缓存。\n\t* 可按照缓存空间容量进行设置。\n\t* 按照时间、次数等过期策略。\n\n* [《Guava Cache》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html)\n\t* 简单轻量、无堆外、磁盘缓存。\n\n\n* [《Nginx本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html)\n\n* [《Pagespeed—懒人工具，服务器端加速》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html)\n\n## 客户端缓存\n\n* [《浏览器端缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html)\n\t* 主要是利用 Cache-Control 参数。\n\n* [《H5 和移动端 WebView 缓存机制解析与实战》](https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w)\n\n## 服务端缓存\n\n### Web缓存\n\n* [nuster](https://github.com/jiangwenyuan/nuster) - nuster cache\n* [varnish](https://github.com/varnishcache/varnish-cache) - varnish cache\n* [squid](https://github.com/squid-cache/squid) - squid cache\n\n### Memcached\n* [《Memcached 教程》](http://www.runoob.com/Memcached/Memcached-tutorial.html)\n* [《深入理解Memcached原理》](https://blog.csdn.net/chenleixing/article/details/47035453)\n\t* 采用多路复用技术提高并发性。\n\t* slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。\n* [《Memcached软件工作原理》](https://www.jianshu.com/p/36e5cd400580)\n* [《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》](http://zhihuzeye.com/archives/2361)\n\n* [《memcache 中 add 、 set 、replace 的区别》](https://blog.csdn.net/liu251890347/article/details/37690045)\n\t* 区别在于当key存在还是不存在时，返回值是true和false的。\n\n* [**《memcached全面剖析》**](https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=)\n\n### Redis\n\n* [《Redis 教程》](http://www.runoob.com/redis/redis-tutorial.html)\n* [《redis底层原理》](https://blog.csdn.net/wcf373722432/article/details/78678504)\n\t* 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。\n\t* 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。\n* [《Redis持久化方式》](http://doc.redisfans.com/topic/persistence.html)\n\t* RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。\n\t* AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。\n\t* 也可以两者结合使用。\n\n* [《分布式缓存--序列3--原子操作与CAS乐观锁》](https://blog.csdn.net/chunlongyu/article/details/53346436)\n\n#### 架构\n* [《Redis单线程架构》](https://blog.csdn.net/sunhuiliang85/article/details/73656830)\n\n#### 回收策略\n* [《redis的回收策略》](https://blog.csdn.net/qq_29108585/article/details/63251491)\n\n### Tair\n\n* [官方网站](https://github.com/alibaba/tair)\n* [《Tair和Redis的对比》](http://blog.csdn.net/farphone/article/details/53522383)\n* 特点：可以配置备份节点数目，通过异步同步到备份节点\n* 一致性Hash算法。\n* 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。\n\n\n几种存储引擎:\n* MDB，完全内存性，可以用来存储Session等数据。\n* Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作\n* LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。\n* Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。\n\n## 消息队列\n\n* [《消息队列-推/拉模式学习 & ActiveMQ及JMS学习》](https://www.cnblogs.com/charlesblc/p/6045238.html)\n\t* RabbitMQ 消费者默认是推模式（也支持拉模式）。\n\t* Kafka 默认是拉模式。\n\t* Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。\n\t* Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。\n\n* [《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》](https://blog.csdn.net/yunfeng482/article/details/72856762)\n\n### 消息总线\n\n消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。\n\n* [《消息总线VS消息队列》](https://blog.csdn.net/yanghua_kobe/article/details/43877281)\n\n### 消息的顺序\n* [《如何保证消费者接收消息的顺序》](https://www.cnblogs.com/cjsblog/p/8267892.html)\n\n### RabbitMQ\n\n支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。\n\n* [《RabbitMQ的应用场景以及基本原理介绍》](https://blog.csdn.net/whoamiyang/article/details/54954780)\n* [《消息队列之 RabbitMQ》](https://www.jianshu.com/p/79ca08116d57) \n* [《RabbitMQ之消息确认机制（事务+Confirm）》](https://blog.csdn.net/u013256816/article/details/55515234)\n\n### RocketMQ\nJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。\n* [《RocketMQ 实战之快速入门》](https://www.jianshu.com/p/824066d70da8)\n* [《RocketMQ 源码解析》](http://www.iocoder.cn/categories/RocketMQ/?vip&architect-awesome)\n\n### ActiveMQ\n纯Java实现，兼容JMS，可以内嵌于Java应用中。\n* [《ActiveMQ消息队列介绍》](https://www.cnblogs.com/wintersun/p/3962302.html)\n\n### Kafka\n高吞吐量、采用拉模式。适合高IO场景，比如日志同步。\n\n* [官方网站](http://kafka.apache.org/)\n* [《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》](https://blog.csdn.net/allthesametome/article/details/47362451)\n* [《Kafka分区机制介绍与示例》](http://lxw1234.com/archives/2015/10/538.htm)\n\n### Redis 消息推送\n\n生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。\n\n* [《Redis学习笔记之十：Redis用作消息队列》](https://blog.csdn.net/qq_34212276/article/details/78455004)\n\n### ZeroMQ\n TODO\n\n\n## 定时调度\n\n### 单机定时调度\n\n* [《linux定时任务cron配置》](https://www.cnblogs.com/shuaiqing/p/7742382.html)\n\n* [《Linux cron运行原理》](https://my.oschina.net/daquan/blog/483305)\n\t* fork 进程 + sleep 轮询\n\n* [《Quartz使用总结》](https://www.cnblogs.com/drift-ice/p/3817269.html)\n* [《Quartz源码解析 ---- 触发器按时启动原理》](https://blog.csdn.net/wenniuwuren/article/details/42082981/)\n* [《quartz原理揭秘和源码解读》](https://www.jianshu.com/p/bab8e4e32952)\n\t* 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。\n\n\n### 分布式定时调度\n\n* [《这些优秀的国产分布式任务调度系统，你用过几个？》](https://blog.csdn.net/qq_16216221/article/details/70314337)\n\t* opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares\n\n* [《Quartz任务调度的基本实现原理》](https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html)\n\t* Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 \n* [《Elastic-Job-Lite 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&architect-awesome)\n* [《Elastic-Job-Cloud 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&architect-awesome)\n\n\n## RPC\n\n* [《从零开始实现RPC框架 - RPC原理及实现》](https://blog.csdn.net/top_code/article/details/54615853)\n\t* 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。\n\n* [《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》](https://blog.csdn.net/testcs_dn/article/details/78050590)\n\n### Dubbo\n* [官方网站](http://dubbo.apache.org/)\n* [dubbo实现原理简单介绍](https://www.cnblogs.com/steven520213/p/7606598.html)\n\n** SPI **\nTODO\n\n### Thrift\n* [官方网站](http://thrift.apache.org/)\n* [《Thrift RPC详解》](https://blog.csdn.net/kesonyk/article/details/50924489)\n\t* 支持多语言，通过中间语言定义接口。\n\n### gRPC\n\n服务端可以认证加密，在外网环境下，可以保证数据安全。\n\n* [官方网站](https://grpc.io/)\n* [《你应该知道的RPC原理》](https://www.cnblogs.com/LBSer/p/4853234.html)\n\n\n## 数据库中间件\n\n### Sharding Jdbc\n\n* [官网](http://shardingjdbc.io/)\n\n## 日志系统\n\n### 日志搜集\n\n* [《从零开始搭建一个ELKB日志收集系统》](http://cjting.me/misc/build-log-system-with-elkb/)\n* [《用ELK搭建简单的日志收集分析系统》](https://blog.csdn.net/lzw_2006/article/details/51280058)\n* [《日志收集系统-探究》](https://www.cnblogs.com/beginmind/p/6058194.html)\n\n## 配置中心\n\n* [Apollo - 携程开源的配置中心应用](https://github.com/ctripcorp/apollo)\n\t* Spring Boot 和 Spring Cloud\n\t* 支持推、拉模式更新配置\n\t* 支持多种语言 \n\n* [《基于zookeeper实现统一配置管理》](https://blog.csdn.net/u011320740/article/details/78742625)\n\n* [《 Spring Cloud Config 分布式配置中心使用教程》](https://www.cnblogs.com/shamo89/p/8016908.html)\n\nservlet 3.0 异步特性可用于配置中心的客户端\n* [《servlet3.0 新特性——异步处理》](https://www.cnblogs.com/dogdogwang/p/7151866.html)\n\n## API 网关\n\n主要职责：请求转发、安全认证、协议转换、容灾。\n\n* [《API网关那些儿》](http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/)\n* [《谈API网关的背景、架构以及落地方案》](http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo)\n\n* [《使用Zuul构建API Gateway》](https://blog.csdn.net/zhanglh046/article/details/78651993)\n* [《Spring Cloud Gateway 源码解析》](http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&architect-awesome)\n* [《HTTP API网关选择之一Kong介绍》](https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A)\n\n# 网络\n\n\n## 协议\n\n### OSI 七层协议\n\n* [《OSI七层协议模型、TCP/IP四层模型学习笔记》](https://www.cnblogs.com/Robin-YB/p/6668762.html)\n\n### TCP/IP\n* [《深入浅出 TCP/IP 协议》](https://www.cnblogs.com/onepixel/p/7092302.html)\n* [《TCP协议中的三次握手和四次挥手》](https://blog.csdn.net/whuslei/article/details/6667471/)\n\n### HTTP\n* [《http协议详解(超详细)》](https://www.cnblogs.com/wangning528/p/6388464.html)\n\n### HTTP2.0\n* [《HTTP 2.0 原理详细分析》](https://blog.csdn.net/zhuyiquan/article/details/69257126)\n* [《HTTP2.0的基本单位为二进制帧》](https://blog.csdn.net/u012657197/article/details/77877840)\n\t* 利用二进制帧负责传输。\n\t* 多路复用。\n\n### HTTPS\n* [《https原理通俗了解》](https://www.cnblogs.com/zhangshitong/p/6478721.html)\n\t* 使用非对称加密协商加密算法\n\t* 使用对称加密方式传输数据\n\t* 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。\n\n* [《八大免费SSL证书-给你的网站免费添加Https安全加密》](https://blog.csdn.net/enweitech/article/details/53213862)\n\n## 网络模型\n\n* [《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》](http://blog.51cto.com/litaotao/1289790)\n\t* 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。\n\t* 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。\n\n* [《select、poll、epoll之间的区别总结》](http://www.cnblogs.com/Anker/p/3265058.html)\n\t* select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。\n\t* select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。\n\t* select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。\n\t* poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。\n\t\n* [《select，poll，epoll比较  》](http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/)\n\t* 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。\n\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n\t* NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务\n\n* [《BIO与NIO、AIO的区别》](https://blog.csdn.net/skiof007/article/details/52873421)\n\n* [《两种高效的服务器设计模型：Reactor和Proactor模型》](https://blog.csdn.net/u013074465/article/details/46276967)\n\n### Epoll\n\n* [《epoll使用详解（精髓）》](https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html)\n\n### Java NIO\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n* [《Java NIO编写Socket服务器的一个例子》](https://blog.csdn.net/xidianliuy/article/details/51612676)\n\n### kqueue\n* [《kqueue用法简介》](http://www.cnblogs.com/luminocean/p/5631336.html)\n\n## 连接和短连接\n\n* [《TCP/IP系列——长连接与短连接的区别》](https://www.cnblogs.com/pangguoping/p/5571422.html)\n\n## 框架\n\n* [《Netty原理剖析》](https://blog.csdn.net/excellentyuxiao/article/details/53390408)\n\t* Reactor 模式介绍。\n\t* Netty 是 Reactor 模式的一种实现。\n\n## 零拷贝（Zero-copy）\n* [《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》](https://www.cnblogs.com/xys1228/p/6088805.html)\n\t* 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。\n\n## 序列化(二进制协议)\n\n### Hessian\n* [《Hessian原理分析》](https://www.cnblogs.com/happyday56/p/4268249.html)\nBinary-RPC;不仅仅是序列化\n\n### Protobuf\n* [《Protobuf协议的Java应用例子》](https://blog.csdn.net/antgan/article/details/52103966)\nGoolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。\n* [《Protocol Buffers序列化协议及应用》](https://worktile.com/tech/share/prototol-buffers)\n  \t* 关于协议的解释；缺点：可读性差;\n\n* [《简单的使用 protobuf 和 protostuff》](https://blog.csdn.net/eric520zenobia/article/details/53766571)\n\t* protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。\n\n# 数据库\n## 基础理论\n### 数据库设计的三大范式\n* [《数据库的三大范式以及五大约束》](https://www.cnblogs.com/waj6511988/p/7027127.html)\n\t* 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；\n\t* 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；\n\t* 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；\n\n## MySQL\n\n### 原理\n* [《MySQL的InnoDB索引原理详解》](http://www.admin10000.com/document/5372.html)\n\n* [《MySQL存储引擎－－MyISAM与InnoDB区别》](https://blog.csdn.net/xifeijian/article/details/20316775)\n\t* 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁\n\n* [《myisam和innodb索引实现的不同》](https://www.2cto.com/database/201211/172380.html)\n\n### InnoDB\n\n* [《一篇文章带你读懂Mysql和InnoDB》](https://my.oschina.net/kailuncen/blog/1504217)\n\n### 优化\n\n* [《MySQL36条军规》](http://vdisk.weibo.com/s/muWOT)\n\n* [《MYSQL性能优化的最佳20+条经验》](https://www.cnblogs.com/zhouyusheng/p/8038224.html)\n* [《SQL优化之道》](https://blog.csdn.net/when_less_is_more/article/details/70187459)\n* [《mysql数据库死锁的产生原因及解决办法》](https://www.cnblogs.com/sivkun/p/7518540.html)\n* [《导致索引失效的可能情况》](https://blog.csdn.net/monkey_d_feilong/article/details/52291556)\n* [《 MYSQL分页limit速度太慢优化方法》](https://blog.csdn.net/zy_281870667/article/details/51604540)\n\t* 原则上就是缩小扫描范围。\n\n\n### 索引\n\n#### 聚集索引, 非聚集索引\n\n* [《MySQL 聚集索引/非聚集索引简述》](https://blog.csdn.net/no_endless/article/details/77073549)\n* [《MyISAM和InnoDB的索引实现》](https://www.cnblogs.com/zlcxbb/p/5757245.html)\n\nMyISAM 是非聚集，InnoDB 是聚集\n\n#### 复合索引\n\n* [《复合索引的优点和注意事项》](https://www.cnblogs.com/summer0space/p/7247778.html)\n\n#### 自适应哈希索引(AHI)\n\n* [《InnoDB存储引擎——自适应哈希索引》](https://blog.csdn.net/Linux_ever/article/details/62043708)\n\n\n### explain\n* [《MySQL 性能优化神器 Explain 使用分析》](https://segmentfault.com/a/1190000008131735)\n\n## NoSQL\n\n### MongoDB\n\n* [MongoDB 教程](http://www.runoob.com/mongodb/mongodb-tutorial.html)\n* [《Mongodb相对于关系型数据库的优缺点》](http://mxdxm.iteye.com/blog/2093603)\n\t* 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；\n\t* 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；\n\n### Hbase\n\n* [《简明 HBase 入门教程（开篇）》](http://www.thebigdata.cn/HBase/35831.html)\n* [《深入学习HBase架构原理》](https://www.cnblogs.com/qiaoyihang/p/6246424.html)\n* [《传统的行存储和（HBase）列存储的区别》](https://blog.csdn.net/youzhouliu/article/details/67632882)\n\n\n* [《Hbase与传统数据库的区别》](https://blog.csdn.net/lifuxiangcaohui/article/details/39891099)\n\t* 空数据不存储，节省空间，且适用于并发。\n\n* [《HBase Rowkey设计》](https://blog.csdn.net/u014091123/article/details/73163088)\n\t* rowkey 按照字典顺序排列，便于批量扫描。\n\t* 通过散列可以避免热点。\n\n# 搜索引擎\n\n## 搜索引擎原理\n\n* [《倒排索引--搜索引擎入门》](https://www.jianshu.com/p/0193dc44135b)\n\n## Lucene\n* [《Lucene入门简介》](https://www.cnblogs.com/rodge-run/p/6551152.html)\n\n## Elasticsearch\n\n* [《Elasticsearch学习，请先看这一篇！》](https://blog.csdn.net/laoyang360/article/details/52244917)\n* [《Elasticsearch索引原理》](https://blog.csdn.net/cyony/article/details/65437708)\n\n## Solr\n* [《 Apache Solr入门教程》](https://blog.csdn.net/u011936655/article/details/51960005)\n* [《elasticsearch与solr比较》](https://blog.csdn.net/convict_eva/article/details/53537837)\n\n## sphinx \n* [《Sphinx 的介绍和原理探索》](http://blog.jobbole.com/101672/)\n\n# 性能\n\n## 性能优化方法论\n\n* [《15天的性能优化工作，5方面的调优经验》](https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread)\n\t* 代码层面、业务层面、数据库层面、服务器层面、前端优化。\n\n* [《系统性能优化的几个方面》](https://blog.csdn.net/tenglizhe/article/details/44563135)\n\n## 容量评估\n* [《联网性能与容量评估的方法论和典型案例》](https://blog.csdn.net/u012528360/article/details/70054156)\n* [《互联网架构，如何进行容量设计？》](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959542&idx=1&sn=2494bbea9a855e0e1c3ccd6d2562a600&scene=21#wechat_redirect)\n\t* 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS\n\n## CDN 网络\n\n* [《CDN加速原理》](https://www.cnblogs.com/wxiaona/p/5867685.html)\n* [《国内有哪些比较好的 CDN？》](https://www.zhihu.com/question/20536932)\n\n## 连接池\n\n* [《主流Java数据库连接池比较与开发配置实战》](https://blog.csdn.net/fysuccess/article/details/66972554)\n\n## 性能调优\n\n* [《九大Java性能调试工具，必备至少一款》](https://blog.csdn.net/yethyeth/article/details/73266455)\n\n\n# 大数据\n\n## 流式计算\n\n### Storm\n* [官方网站](http://storm.apache.org/)\n* [《最详细的Storm入门教程》](https://blog.csdn.net/uisoul/article/details/77989927)\n\n### Flink\n* [《Flink之一 Flink基本原理介绍》](https://blog.csdn.net/lisi1129/article/details/54844919)\n\n### Kafka Stream\n* [《Kafka Stream调研：一种轻量级流计算模式》](https://yq.aliyun.com/articles/58382)\n\n### 应用场景\n\n例如：\n\n* 广告相关实时统计；\n* 推荐系统用户画像标签实时更新；\n* 线上服务健康状况实时监测；\n* 实时榜单；\n* 实时数据统计。\n\n## Hadoop\n\n* [《用通俗易懂的话说下hadoop是什么,能做什么》](https://blog.csdn.net/houbin0912/article/details/72967178)\n* [《史上最详细的Hadoop环境搭建》](http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html)\n\n### HDFS\n* [《【Hadoop学习】HDFS基本原理》](https://segmentfault.com/a/1190000011575458)\n\n### MapReduce\n* [《用通俗易懂的大白话讲解Map/Reduce原理》](https://blog.csdn.net/oppo62258801/article/details/72884633)\n* [《 简单的map-reduce的java例子》](https://blog.csdn.net/foye12/article/details/78358292)\n\n### Yarn\n* [《初步掌握Yarn的架构及原理》](http://www.cnblogs.com/codeOfLife/p/5492740.html)\n\n## Spark\n* [《Spark(一): 基本架构及原理》](http://www.cnblogs.com/tgzhu/p/5818374.html)\n\n\n# 安全\n\n## web 安全\n\n### XSS\n* [《xss攻击原理与解决方法》](https://blog.csdn.net/qq_21956483/article/details/54377947)\n### CSRF\n* [《CSRF原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html)\n\n### SQL 注入\n\n* [《SQL注入》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html)\n\n### Hash Dos\n\n\n* [《邪恶的JAVA HASH DOS攻击》](http://www.freebuf.com/articles/web/14199.html)\n\t* 利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。\n* [《一种高级的DoS攻击-Hash碰撞攻击》](http://blog.it2048.cn/article_hash-collision.html )\n* [《关于Hash Collision DoS漏洞：解析与解决方案》](http://www.iteye.com/news/23939/)\n\n### 脚本注入\n\n* [《上传文件漏洞原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html)\n\n### 漏洞扫描工具\n* [《DVWA》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html)\n* [W3af](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html)\n* [OpenVAS详解](https://blog.csdn.net/xygg0801/article/details/53610640)\n\n### 验证码\n\n* [《验证码原理分析及实现》](https://blog.csdn.net/niaonao/article/details/51112686)\n\n* [《详解滑动验证码的实现原理》](https://my.oschina.net/jiangbianwanghai/blog/1031031)\n\t* 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。\n\n* [《淘宝滑动验证码研究》](https://www.cnblogs.com/xcj26/p/5242758.html)\n\n## DDoS 防范\n* [《学习手册：DDoS的攻击方式及防御手段》](http://netsecurity.51cto.com/art/201601/503799.htm)\n* [《免费DDoS攻击测试工具大合集》](http://netsecurity.51cto.com/art/201406/442756.htm)\n\n## 用户隐私信息保护\n\n1. 用户密码非明文保存，加动态salt。\n2. 身份证号，手机号如果要显示，用 “\\*” 替代部分字符。\n3. 联系方式在的显示与否由用户自己控制。\n4. TODO\n\n* [《个人隐私包括哪些》](https://zhidao.baidu.com/question/1988017976673661587.html)\n* [《在互联网上，隐私的范围包括哪些？》](https://www.zhihu.com/question/20137108)\n\n* [《用户密码保存》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html)\n\n## 序列化漏洞\n* [《Lib之过？Java反序列化漏洞通用利用分析》](https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/)\n\n## 加密解密\n\n### 对称加密\n\n* [《常见对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html)\n\t* DES、3DES、Blowfish、AES\n\t* DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。\n\t* DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。\n\t\n### 哈希算法\n* [《常用的哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html)\n\t* MD5 和 SHA-1 已经不再安全，已被弃用。\n\t* 目前 SHA-256 是比较安全的。\n\t\n* [《基于Hash摘要签名的公网URL签名验证设计方案》](https://blog.csdn.net/zhangruhong168/article/details/78033202)\n\n### 非对称加密\n* [《常见非对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html)\n\t* RSA、DSA、ECDSA(螺旋曲线加密算法)\n\t* 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。\n\t* 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。\n\n\t\t[《区块链的加密技术》](http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc)\t\n\n\n## 服务器安全\n* [《Linux强化论：15步打造一个安全的Linux服务器》](http://www.freebuf.com/articles/system/121540.html)\n\n## 数据安全\n\n### 数据备份\n\nTODO\n\n## 网络隔离\n\n### 内外网分离\n\nTODO\n\n### 登录跳板机\n在内外环境中通过跳板机登录到线上主机。\n* [《搭建简易堡垒机》](http://blog.51cto.com/zero01/2062618)\n\n## 授权、认证\n### RBAC \n* [《基于组织角色的权限设计》](https://www.cnblogs.com/zq8024/p/5003050.html)\n* [《权限系统与RBAC模型概述》](https://www.cnblogs.com/shijiaqi1066/p/3793894.html)\n* [《Spring整合Shiro做权限控制模块详细案例分析》](https://blog.csdn.net/he90227/article/details/38663553)\n\n### OAuth2.0\n* [《理解OAuth 2.0》](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n* [《一张图搞定OAuth2.0》](https://www.cnblogs.com/flashsun/p/7424071.html)\n\n### 双因素认证（2FA）\n\n2FA - Two-factor authentication，用于加强登录验证\n\n常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）\n\n* 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html)\n\n### 单点登录(SSO)\n\n* [《单点登录原理与简单实现》](https://www.cnblogs.com/ywlaker/p/6113927.html)\n\n* [CAS单点登录框架](https://github.com/apereo/cas)\n\n# 常用开源框架\n\n## 开源协议\n\n* [《开源协议的选择》](https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html)\n\n* [如何选择一个开源软件协议](http://choosealicense.online/)\n\n## 日志框架\n\n### Log4j、Log4j2\n* [《log4j 详细讲解》](https://blog.csdn.net/u012422446/article/details/51199724)\n* [《log4j2 实际使用详解》](https://blog.csdn.net/vbirdbest/article/details/71751835)\n* [《Log4j1,Logback以及Log4j2性能测试对比》](https://my.oschina.net/OutOfMemory/blog/789267)\n\t* Log4J 异步日志性能优异。 \n\n### Logback\n* [《最全LogBack 详解、含java案例和配置说明》](https://blog.csdn.net/rulon147/article/details/52620541)\n\n## ORM\n\n* [《ORM框架使用优缺点》](https://blog.csdn.net/sinat_34093604/article/details/53082000)\n\t* 主要目的是为了提高开发效率。 \n\n**MyBatis：**\n\n* [《mybatis缓存机制详解》](https://www.cnblogs.com/winclpt/articles/7511672.html)\n\t* 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效\n\t* 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  \n\n* [《MyBatis学习之代码生成器Generator》](https://blog.csdn.net/baidu_32877851/article/details/53959268)\n\n## 网络框架\n\nTODO\n\n## Web 框架\n\n### Spring 家族\n**Spring**\n* [Spring 简明教程](https://www.w3cschool.cn/wkspring/)\n\n**Spring Boot**\n* [官方网站](http://projects.spring.io/spring-boot/)\n* [《Spring Boot基础教程》](http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n**Spring Cloud**\n\n* [Spring Boot 中文索引站](http://springboot.fun/)\n* [Spring Cloud 中文文档](https://springcloud.cc/)\n* [《Spring Cloud基础教程》](http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n## 工具框架\n\n* [《Apache Commons 工具类介绍及简单使用》](https://www.cnblogs.com/crazylqy/p/4872236.html)\n* [《Google guava 中文教程》](http://ifeve.com/google-guava/)\n\n\n# 分布式设计\n\n## 扩展性设计\n\n* [《架构师不可不知的十大可扩展架构》](https://blog.csdn.net/hemin1003/article/details/53633926)\n\t* 总结下来，通用的套路就是分布、缓存及异步处理。 \n\n* [《可扩展性设计之数据切分》](https://yq.aliyun.com/articles/38119)\n\t* 水平切分+垂直切分\n\t* 利用中间件进行分片如，MySQL Proxy。\n\t* 利用分片策略进行切分，如按照ID取模。 \n* [《说说如何实现可扩展性的大型网站架构》](https://blog.csdn.net/deniro_li/article/details/78458306)\n\t* 分布式服务+消息队列。\n\n* [《大型网站技术架构（七）--网站的可扩展性架构》](https://blog.csdn.net/chaofanwei/article/details/29191073)\n\n## 稳定性 & 高可用\n\n* [《系统设计：关于高可用系统的一些技术方案》](https://blog.csdn.net/hustspy1990/article/details/78008324)\n\t* 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。\n\t* 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。\n\t* 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。\n\t* 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。\n\t* 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。\n\t* 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。\n\t* 自动化测试：通过完善的测试，减少发布引起的故障。\n\t* 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。\n\n\n* [《关于高可用的系统》](https://coolshell.cn/articles/17459.html)\n\t* 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。\t \n\n### 硬件负载均衡\n\n* [《转！！负载均衡器技术Nginx和F5的优缺点对比》](https://www.cnblogs.com/wuyun-blog/p/6186198.html)\n\t* 主要是和F5对比。\n\n* [《软/硬件负载均衡产品 你知多少？》](https://www.cnblogs.com/lcword/p/5773296.html)\n\n### 软件负载均衡\n\n* [《几种负载均衡算法》](https://www.cnblogs.com/tianzhiliang/articles/2317808.html)\n\t轮寻、权重、负载、最少连接、QoS\n* [《DNS负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html)\n\t* 配置简单，更新速度慢。 \n* [《Nginx负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html)\n\t* 简单轻量、学习成本低；主要适用于web应用。\n\n*  [《借助LVS+Keepalived实现负载均衡 》](https://www.cnblogs.com/edisonchou/p/4281978.html)\n\t* 配置比较负载、只支持到4层，性能较高。\n\n* [《HAProxy用法详解 全网最详细中文文档》](http://www.ttlsa.com/linux/haproxy-study-tutorial/)\n\t* 支持到七层（比如HTTP）、功能比较全面，性能也不错。\n\n* [《Haproxy+Keepalived+MySQL实现读均衡负载》](http://blog.itpub.net/25704976/viewspace-1319781/)\n\t* 主要是用户读请求的负载均衡。\n\n* [《rabbitmq+haproxy+keepalived实现高可用集群搭建》](https://www.cnblogs.com/lylife/p/5584019.html)\n\n### 限流\n\n* [《谈谈高并发系统的限流》](https://www.cnblogs.com/haoxinyue/p/6792309.html)\n\t* 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。\n\t* 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。\n\t* 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。\n\t* Nginx 限流：通过 `limit_req` 等模块限制并发连接数。\n\n### 应用层容灾\n\n* [《防雪崩利器：熔断器 Hystrix 的原理与使用》](https://segmentfault.com/a/1190000005988895)\n\t* 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 \n\t* 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。\n\t* Hystrix设计原则：\n\t\t* 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。\n\t\t* 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。\n\t\t* 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 \n\n* [《缓存穿透，缓存击穿，缓存雪崩解决方案分析》](https://blog.csdn.net/zeb_perfect/article/details/54135506)\n* [《缓存击穿、失效以及热点key问题》](https://blog.csdn.net/zeb_perfect/article/details/54135506) \n\t* 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；\n\t* 热点数据：热点数据单独存储；使用本地缓存；分成多个子key；\n\n### 跨机房容灾\n\n* [《“异地多活”多机房部署经验谈》](http://dc.idcquan.com/ywgl/71559.shtml)\n\t* 通过自研中间件进行数据同步。 \n\n* [《异地多活（异地双活）实践经验》](https://blog.csdn.net/jeffreynicole/article/details/48135093)\n\t* 注意延迟问题，多次跨机房调用会将延时放大数倍。\n\t* 建房间专线很大概率会出现问题，做好运维和程序层面的容错。\n\t* 不能依赖于程序端数据双写，要有自动同步方案。 \n\t* 数据永不在高延迟和较差网络质量下，考虑同步质量问题。\n\t* 核心业务和次要业务分而治之，甚至只考虑核心业务。\n\t* 异地多活监控部署、测试也要跟上。\n\t* 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。\n\t* 控制跨机房消息体大小，越小越好。\n\t* 考虑使用docker容器虚拟化技术，提高动态调度能力。\n\n* [容灾技术及建设经验介绍](https://blog.csdn.net/yoara/article/details/38013751)\n\n\n### 容灾演练流程\n\n* [《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650996320&idx=1&sn=0ed3be190bbee4a9277886ef88cbb2e5)\n\t* 常见故障画像\n\t* 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。\n\n### 平滑启动\n\n* 平滑重启应用思路\n1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用\n\n* [《JVM安全退出（如何优雅的关闭java服务）》](https://blog.csdn.net/u011001084/article/details/73480432)\n推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。\n* [《常见Java应用如何优雅关闭》](http://ju.outofmemory.cn/entry/337235)\nJava、Spring、Dubbo 优雅关闭方式。\n\n## 数据库扩展\n\n### 读写分离模式\n\n* [《Mysql主从方案的实现》](https://www.cnblogs.com/houdj/p/6563771.html)\n* [《搭建MySQL主从复制经典架构》](https://www.cnblogs.com/edisonchou/p/4133148.html)\n* [《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》](https://blog.csdn.net/nimasike/article/details/48048341)\n\n* [《DRBD+Heartbeat+Mysql高可用读写分离架构》](https://www.cnblogs.com/zhangsubai/p/6801764.html)\n\t* DRDB 进行磁盘复制，避免单点问题。\n\n* [《MySQL Cluster 方式》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html)\n\n### 分片模式\n* [《分库分表需要考虑的问题及方案》](https://www.jianshu.com/p/32b3e91aa22c)\n\t* 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。\n\t* 问题：事务、Join、迁移、扩容、ID、分页等。\n\t* 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。\n\t* 分库策略：数值范围；取模；日期等。\n\t* 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 \n\n* [《MySql分表和表分区详解》](https://www.2cto.com/database/201503/380348.html)\n\t* 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。\n\t* 分表：物理上创建不同的表、客户端需要管理分表路由。\n\n## 服务治理\n###  服务注册与发现\n\n* [《永不失联！如何实现微服务架构中的服务发现？》](https://blog.csdn.net/jiaolongdy/article/details/51188798)\n  * 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。\n  * 服务器端服务发现模式：客户端通过负载均衡查询服务实例。\n* [《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》](https://blog.csdn.net/u010963948/article/details/71730165)\n  * CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）\n  * 作者认为目前 Consul 对 Spring cloud 的支持比较好。\n\n* [《基于Zookeeper的服务注册与发现》](http://mobile.51cto.com/news-502394.htm)\n\t* 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 \n\n### 服务路由控制\n* [《分布式服务框架学习笔记4 服务路由》](https://blog.csdn.net/xundh/article/details/59492750)\n\t* 原则：透明化路由\n\t* 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接\n\t* 本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。\n\t* 配置方式：统一注册表；本地配置；动态下发。\n\n## 分布式一致\n\n### CAP 与 BASE 理论\n\n* [《从分布式一致性谈到CAP理论、BASE理论》](http://www.cnblogs.com/szlbm/p/5588543.html)\n\t* 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)\n\t* CAP：一致性、可用性、分区容错性(网络故障引起)\n\t* BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）\n\t* BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n### 分布式锁\n\n* [《分布式锁的几种实现方式》](http://www.hollischuang.com/archives/1716)\n\t* 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；\n\t* 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。\n\t* Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。\n* [《基于Zookeeper的分布式锁》](https://www.tuicool.com/articles/VZJr6fY)\n\t* 清楚的原理描述 + Java 代码示例。 \n\n* [《jedisLock—redis分布式锁实现》](https://www.cnblogs.com/0201zcr/p/5942748.html)\n\t* 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。\n\n* [《Memcached 和 Redis 分布式锁方案》](https://blog.csdn.net/albertfly/article/details/77412333)\n\t* 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。\n\n### 分布式一致性算法\n\n#### PAXOS\n* [《分布式系列文章——Paxos算法原理与推导》](https://www.cnblogs.com/linbingdong/p/6253479.html)\n* [《Paxos-->Fast Paxos-->Zookeeper分析》](https://blog.csdn.net/u010039929/article/details/70171672)\n* [《【分布式】Zookeeper与Paxos》](https://www.cnblogs.com/leesf456/p/6012777.html)\n\n#### Zab\n* [《Zab：Zookeeper 中的分布式一致性协议介绍》](https://www.jianshu.com/p/fb527a64deee)\n\n#### Raft\n* [《Raft 为什么是更易理解的分布式一致性算法》](http://www.cnblogs.com/mindwind/p/5231986.html)\n\t* 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）\n\t* 通过随机等待的方式发出投票，得票多的获胜。\n\n#### Gossip\n* [《Gossip算法》](http://blog.51cto.com/tianya23/530743)\n\n#### 两阶段提交、多阶段提交\n\n* [《关于分布式事务、两阶段提交协议、三阶提交协议》](http://blog.jobbole.com/95632/)\n\n### 幂等\n\n* [《分布式系统---幂等性设计》](https://www.cnblogs.com/wxgblogs/p/6639272.html)\n\t* 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。\n\t* 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 \n\n### 分布式一致方案\n* [《分布式系统事务一致性解决方案》](http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency)\n* [《保证分布式系统数据一致性的6种方案》](https://weibo.com/ttarticle/p/show?id=2309403965965003062676)\n\n### 分布式 Leader 节点选举\n* [《利用zookeeper实现分布式leader节点选举》](https://blog.csdn.net/johnson_moon/article/details/78809995)\n\n### TCC(Try/Confirm/Cancel) 柔性事务\n* [《传统事务与柔性事务》](https://www.jianshu.com/p/ab1a1c6b08a1)\n\t* 基于BASE理论：基本可用、柔性状态、最终一致。\n\t* 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。\n\n## 分布式文件系统\n\n* [说说分布式文件存储系统-基本架构](https://zhuanlan.zhihu.com/p/27666295) ？\n* [《各种分布式文件系统的比较》](https://blog.csdn.net/gatieme/article/details/44982961) ？\n  * HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。\n  * FastDFS：轻量级、适合小文件。\n\n## 唯一ID 生成\n\n### 全局唯一ID\n* [《高并发分布式系统中生成全局唯一Id汇总》](https://www.cnblogs.com/baiwa/p/5318432.html)\n\t* Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)\n\t* Flicker 方案：MySQL自增ID + \"REPLACE INTO XXX:SELECT LAST_INSERT_ID();\" \n\t* UUID：缺点，无序，字符串过长，占用空间，影响检索性能。\n\t* MongoDB 方案：利用 ObjectId。缺点：不能自增。\n\n* [《TDDL 在分布式下的SEQUENCE原理》](https://blog.csdn.net/hdu09075340/article/details/79103851)\n\t* 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。\n\t* 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。\n\t* 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。\n\n## 一致性Hash算法\n\n* [《一致性哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html)\n\n# 设计思想 & 开发模式\n\n## DDD(Domain-driven Design - 领域驱动设计)\n\n* [《浅谈我对DDD领域驱动设计的理解》](https://www.cnblogs.com/netfocus/p/5548025.html)\n  * 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。\n  * 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。\n  * 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。\n  \n* [《领域驱动设计的基础知识总结》](https://www.cnblogs.com/butterfly100/p/7827870.html)\n  * 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。\n  * 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。\n  * 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；\n  * 领域通用语言：领域专家、开发设计人员都能立即的语言或工具。\n  * 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。\n  * 使用的模式：\n    * 关联尽量少，尽量单项，尽量降低整体复杂度。\n    * 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。\n    * 值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。\n    * 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。\n    * 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；\n    * 工厂（Factory）：类似于设计模式中的工厂模式。\n    * 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。\n\n* [《领域驱动设计(DDD)实现之路》](http://www.cnblogs.com/Leo_wl/p/3866629.html)\n\t* 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。\n\n* [《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》](http://www.hollischuang.com/archives/553)\n\n\n### 命令查询职责分离(CQRS)\n\nCQRS — Command Query Responsibility Seperation\n\n* [《领域驱动设计系列 (六)：CQRS》](https://www.cnblogs.com/cnblogsfans/p/4551990.html)\n\t* 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。\n\n* [《DDD CQRS架构和传统架构的优缺点比较》](http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml)\n\t* 最终一致的设计理念；依赖于高可用消息中间件。\n\t\n* [《CQRS架构简介》](http://www.cnblogs.com/netfocus/p/4055346.html)\n\t* 一个实现 CQRS 的抽象案例。\n\n* [《深度长文：我对CQRS/EventSourcing架构的思考》](http://www.uml.org.cn/zjjs/201609221.asp)\n\t* CQRS 模式分析 + 12306 抢票案例\n\n### 贫血，充血模型\n\n* [《贫血，充血模型的解释以及一些经验》](https://kb.cnblogs.com/page/520743/)\n\t* 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。\n\t* 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；\n\t* 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。\n\t* 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。\n\t* 作者主张使用贫血模式。\n\t\n## Actor 模式\n\nTODO\n\n## 响应式编程\n\n### Reactor\nTODO\n### RxJava\nTODO\n### Vert.x\nTODO\n\n## DODAF2.0\n\n* [《DODAF2.0方法论》](http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml)\n* [《DODAF2.0之能力视角如何落地》](http://blog.51cto.com/xiaoyong/1553164)\n\n## Serverless\n\n无需过多关系服务器的服务架构理念。\n\n* [《什么是Serverless无服务器架构？》](http://www.jdon.com/soa/serverless.html)\n\t* Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。\n\t* Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。\n\t* Serverless 不代表某个具体的框架。\n\n* [《如何理解Serverless？》](http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless)\n\t* 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）\n\n\n\n## Service Mesh\n\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\n* [《初识 Service Mesh》](https://www.jianshu.com/p/e23e3e74538e)\n\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\n\n# 项目管理\n\n## 架构评审\n* [《架构设计之如何评审架构设计说明书》](http://developer.51cto.com/art/201506/478486.htm)\n* [《人人都是架构师：非功能性需求》](https://blog.csdn.net/wireless_com/article/details/45935591)\n\n## 重构\n\n* [《架构之重构的12条军规》](http://www.infoq.com/cn/articles/architect-12-rules-complete/)\n\n## 代码规范\n\n* [《阿里巴巴Java开发手册》](https://github.com/alibaba/p3c)\n\n## 代码 Review\n\n\n制度还是制度!\n另外，每个公司需要根据自己的需求和目标制定自己的 check list\n\n* [《为什么你做不好 Code Review？》](http://www.sohu.com/a/229745352_181657)\n\t* 代码 review 做的好，在于制度建设。\n\n* [《从零开始Code Review》](https://blog.csdn.net/uxyheaven/article/details/49773619)\n\n* [《Code Review Checklist》](https://www.cnblogs.com/zuoping/p/5477047.html)\n* [《Java Code Review Checklist》](https://dzone.com/articles/java-code-review-checklist)\n\n* [《如何用 gitlab 做 code review》](https://blog.csdn.net/legend0011/article/details/45585575)\n\n## RUP\n* [《运用RUP 4+1视图方法进行软件架构设计》](https://blog.csdn.net/apanious/article/details/51011946)\n\n## 看板管理\n* [《说说看板在项目中的应用》](https://blog.csdn.net/tkchen/article/details/51637643)\n\n## SCRUM\n\nSCRUM - 争球\n\n* 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。\n* 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；\n* 五个价值观：专注、勇气、公开、承诺、尊重。\n\n\n* [《敏捷项目管理流程-Scrum框架最全总结！》](https://blog.csdn.net/inny100_100/article/details/54633757)\n\n* [《敏捷其实很简单3---敏捷方法之scrum》](https://blog.csdn.net/superkunkun/article/details/52951142)\n\n## 敏捷开发\n\nTODO\n\n## 极限编程（XP）\n\nXP - eXtreme Programming\n\n* [《主流敏捷开发方法：极限编程XP》](http://www.woshipm.com/pmd/406917.html)\n\t* 是一种指导开发人员的方法论。\n\t* 4大价值：\n\t\t* 沟通：鼓励口头沟通，提高效率。\n\t\t* 简单：够用就好。\n\t\t* 反馈：及时反馈、通知相关人。\n\t\t* 勇气：提倡拥抱变化，敢于重构。\n\t\t\n\t* 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。\n\t* 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。\n\n## 结对编程\n\n边写码，边review。能够增强代码质量、减少bug。\n\n* [《结对编程》](http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B)\n\n## PDCA 循环质量管理\n\nP——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进\n\n* [《PDCA》](http://www.baike.com/wiki/PDCA)\n\n## FMEA管理模式\n\nTODO\n\n# 通用业务术语\n\nTODO\n\n# 技术趋势\n\nTODO\n\n# 政策、法规\n\nTODO\n## 法律\n\n### 严格遵守刑法253法条\n\n我国刑法第253条之一规定：\n\n> * 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。\n> * 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 \n> * 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。\n\n最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”\n\n* [《非法获取公民个人信息罪》](https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA)\n\n\n# 架构师素质\n\n* [《架构师画像》](http://hellojava.info/?p=430)\n\t* 业务理解和抽象能力\n\t* NB的代码能力\n\t* 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； \n\t* 全局：是否考虑到了对上下游的系统的影响。\n\t* 权衡：权衡投入产出比；优先级和节奏控制；\n\n* [《关于架构优化和设计，架构师必须知道的事情》](http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know)\n\t* 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。\n\t* 基础设施、配置、测试、开发、运维综合考虑。\n\t* 考虑人、团队、和组织的影响。 \n\n* [《如何才能真正的提高自己，成为一名出色的架构师？》](https://www.zhihu.com/question/19841397) \n\n* [《架构师的必备素质和成长途径》](https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129)\n\t* 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。\n\t* 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 \n\n* [《架构设计师—你在哪层楼？》](http://blog.51cto.com/frankfan/1248401)\n\t* 第一层的架构师看到的只是产品本身\n\t* 第二层的架构师不仅看到自己的产品，还看到了整体的方案\n\t* 第三层的架构师看到的是商业价值 \n\n# 团队管理\n\nTODO\n\n## 招聘\n\n# 资讯\n\n## 行业资讯\n\n* [36kr](http://36kr.com/)\n* [Techweb](http://www.techweb.com.cn/)\n\n## 公众号列表\n\nTODO\n\n## 博客\n\n### 团队博客\n* [阿里中间件博客](http://jm.taobao.org/)\n* [美团点评技术团队博客](https://tech.meituan.com)\n\n### 个人博客\n\n* [阮一峰的网络日志](http://www.ruanyifeng.com/)\n* [酷壳 - COOLSHELL-陈皓](https://coolshell.cn/)\n* [hellojava-阿里毕玄](http://hellojava.info/)\n* [Cm's Blog](http://cmsblogs.com/)\n* [程序猿DD-翟永超-《Spring Cloud微服务实战》作者](http://blog.didispace.com/)\n\n## 综合门户、社区\n\n**国内：**\n\n* [CSDN](http://csdn.net)\n\t 老牌技术社区、不必解释。\n* [51cto.com](http://www.51cto.com/)\n* [ITeye](http://www.iteye.com/)\n\t* 偏 Java 方向 \n* [博客园](https://www.cnblogs.com)\n* [ChinaUnix](http://www.tom.net/)\n\t* 偏 Linux 方向 \n* [开源中国社区](https://www.oschina.net/)\n* [深度开源](http://www.open-open.com/)\n* [伯乐在线](http://www.jobbole.com/)\n\t* 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。\n\n* [ITPUB](http://www.itpub.net/)\n* [腾讯云— 云+社区](https://cloud.tencent.com/developer/column)\n* [阿里云— 云栖社区](https://yq.aliyun.com/)\n* [IBM DeveloperWorks](https://www.ibm.com/developerworks/cn/)\n* [开发者头条](https://toutiao.io/)\n* [LinkedKeeper](http://www.linkedkeeper.com)\n\n**国外：**\n\n* [DZone](https://dzone.com)\n* [Reddit](https://www.reddit.com)\n\n## 问答、讨论类社区\n\n* [segmentfault](https://segmentfault.com)\n\t* 问答+专栏 \n* [知乎](https://www.zhihu.com/)\n* [stackoverflow](https://stackoverflow.com/)\n\n## 行业数据分析\n\n* [艾瑞网](http://report.iresearch.cn/)\n* [QUEST MOBILE](https://www.questmobile.com.cn)\n\n* [国家数据](http://data.stats.gov.cn/)\n\n* [TalkingData](http://www.talkingdata.com/)\n\n## 专项网站\n\n* 测试:\n\t* [领测国际](http://www.ltesting.net/) \n\t* [测试窝](https://www.testwo.com/)\n\t* [TesterHome](https://testerhome.com)\n\n* 运维:\n  \t* [运维派](http://www.yunweipai.com/) \n  \t* [Abcdocker](https://www.abcdocker.com/)\n  \n* Java:\n\t* [ImportNew](http://www.importnew.com/)\n\t\t* 专注于 Java 技术分享\n\t* [HowToDoInJava](https://howtodoinjava.com/)\n\t\t* 英文博客\n\t\n* 安全\n\t* [红黑联盟](https://www.2cto.com/) \n\t* [FreeBuf](http://www.freebuf.com/)\n\n* 大数据\n\t* [中国大数据](http://www.thebigdata.cn/) \n\n* 其他专题网站：\n\t* [InfoQ](http://www.infoq.com/cn/)\n\t\t* 偏重于基础架构、运维方向\n\t* [DockerInfo](http://www.dockerinfo.net/)\n\t\t* 专注于 Docker 应用及咨询、教程的网站\n\t* [Linux公社](https://www.linuxidc.com/)\n\t\t* Linux 主题社区\n\n## 其他类\n\n* [程序员技能图谱](https://github.com/TeamStuQ/skill-map)\n\n## 推荐参考书\n\n\n### 在线电子书\n\n* [《深入理解Spring Cloud与微服务构建》](https://github.com/forezp/SpringCloudLearning)\n\n\n* [《阿里技术参考图册-研发篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf)\n* [《阿里技术参考图册-算法篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf)\n\n* [《2018美团点评技术年货（合辑）》70M](http://dpurl.cn/n/1lqcX)\n\n* [InfoQ《架构师》月刊](http://www.infoq.com/cn/architect/)\n\n* [《架构师之路》](https://www.w3cschool.cn/architectroad/)\n\n### 纸质书\n\n#### 开发方面\n\n* 《阿里巴巴Java开发手册》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BfL5CR)\n\n#### 架构方面\n* 《软件架构师的12项修炼：技术技能篇》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=rTlo0m)\n* 《架构之美》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=1KECBZ) \n* 《分布式服务架构》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=hkzqtK) \n* 《聊聊架构》 [详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=A8Nd6Z) \n* 《云原生应用架构实践》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=D4WCpd) \n* 《亿级流量网站架构核心技术》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Rdmd21)\n* 《淘宝技术这十年》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=CoUdGG)\n* 《企业IT架构转型之道-中台战略思想与架构实战》 [详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BxS6eI) \n\n* 《高可用架构（第1卷）》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BcjUwS) \n\n#### 技术管理方面\n* 《CTO说》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Gl3QAo) \n* 《技术管理之巅》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=MeloLt)\n* 《网易一千零一夜：互联网产品项目管理实战》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=qPuqMg) \n\n#### 基础理论\n* 《数学之美》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=0seUpO) \n* 《编程珠玑》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=I7jj9r) \n\n#### 工具方面\nTODO\n\n#### 大数据方面\n\n# 技术资源\n\n## 开源资源\n* [github](https://github.com)\n\n* [Apache 软件基金会](https://www.apache.org/index.html)\n\n## 手册、文档、教程\n\n**国内：**\n* [W3Cschool](http://w3cschool.cn) \n* [Runoob.com](http://www.runoob.com/)\n\t* HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。\n\n* [Love2.io](https://love2.io/)\n\t* 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。\n* [gitbook.cn](http://gitbook.cn/)\n\t* 付费电子书。 \n* [ApacheCN](http://www.apachecn.org/)\n\t* AI、大数据方面系列中文文档。\n\n**国外：**\n\n* [Quick Code](http://www.quickcode.co/)\n\t* 免费在线技术教程。\n* [gitbook.com](http://gitbook.com)\n\t* 有部分中文电子书。\n* [Cheatography](https://www.cheatography.com/)\n\t* Cheat Sheets 大全，单页文档网站。\n* [Tutorialspoint](https://www.tutorialspoint.com/index.htm)\n\t* 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。\n\n\n## 在线课堂\n\n* [学徒无忧](http://www.xuetuwuyou.com/)\n* [极客时间](https://time.geekbang.org/)\n* [segmentfault](https://segmentfault.com/lives)\n* [斯达克学院](https://new.stuq.org/course/explore)\n* [牛客网](http://nowcoder.com)\n* [极客学院](https://www.jikexueyuan.com/)\n* [51CTO学院](http://edu.51cto.com/)\n\n## 会议、活动\n\n* [QCon](http://www.infoq.com/cn/qcon/)\n* [ArchSummit](https://archsummit.com)\n* [GITC全球互联网技术大会](http://www.thegitc.com/)\n\n**活动发布平台:** \n* [活动行](http://www.huodongxing.com/)\n\n## 常用APP\n\n* [极客时间](https://time.geekbang.org)\n* [得到](https://www.igetget.com)\n\n## 找工作\n* [Boss直聘](https://www.zhipin.com)\n* [拉勾网](https://www.lagou.com)\n* [猎聘](https://www.liepin.com)\n* [100Offer](https://cn.100offer.com/)\n\n## 工具\n\n* [极客搜索](https://s.geekbang.org/)\n\t* 技术文章搜索引擎。\n\n## 代码托管\n\n* [Coding](https://coding.net)\n* [码云](https://gitee.com/)\n\n## 文件服务\n* 七牛\n* 又拍云\n\n## 综合云服务商\n* 阿里云\n* [腾讯云](https://cloud.tencent.com/redirect.php?redirect=1012&cps_key=c2665015d90871c0cb20fef91b7afc3c)\n* 百度云\n* 新浪云\n* 金山云\n* [亚马逊云(AWS)](https://amazonaws-china.com/cn/)\n* [谷歌云](https://cloud.google.com/?hl=zh-cn)\n* [微软云](https://azure.microsoft.com/zh-cn/)\n\n### VPS\n* [Linode](http://linode.com)\n* [DigitalOcean](https://www.digitalocean.com)\n* [Vultr](https://www.vultr.com/)\n\n\n\n\n","tags":["学习资料"]},{"title":"Python小实践   微博爬虫之数据分析","url":"/2018/06/20/python 词云/","content":"# python 词云\n## 1. 前期准备\n### 1.1 下载相关库\n* jieba (用于分词)\n* matplotlib\n* wordcloud\n`注意事项:`\n如果相关库安装失败,请到[https://www.lfd.uci.edu/~gohlke/pythonlibs/](https://www.lfd.uci.edu/~gohlke/pythonlibs/)下载相应包手动安装,注意python版本号与操作系统位数,如下图,例如python3.6,64位操作系统则选择`cp36-win_amd64.whl`文件下载\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180905/6Ch55mcee6.png?imageslim)\n### 使用命令行安装相关库\n```powershell\npip install 包名或本地包路径\n```\n## 2. wordcloud\n>wordcloud基于Python的词云生成类库,很好用,而且功能强大\n[Github](https://github.com/amueller/word_cloud )\n[官方文档](https://amueller.github.io/word_cloud)\n[参考博文](https://blog.csdn.net/fly910905/article/details/77763086)\n\n\n## 3. 小试牛刀\n```python\n# coding: utf-8\n\nimport json\n\nimport jieba.analyse\nimport matplotlib as mpl\nfrom scipy.misc import imread\nfrom wordcloud import WordCloud\n\n# mpl.use('TkAgg')\nimport matplotlib.pyplot as plt\n\n\ndef keywords(mblogs):\n    text = []\n    for blog in mblogs:\n        keyword = jieba.analyse.extract_tags(blog['text'])\n        text.extend(keyword)\n    return text\n\n\ndef gen_img(texts, img_file):\n    data = ' '.join(text for text in texts)\n    image_coloring = imread(img_file)\n    wc = WordCloud(\n        background_color='white',\n        mask=image_coloring,\n        max_font_size=500,  # 设置字体最大值\n        font_path='Fonts/HYC6GFM.TTF',\n        random_state = 30  # 设置有多少种随机生成状态，即有多少种配色方案\n    )\n    wc.generate(data)\n    # plt.figure()\n    # plt.imshow(wc, interpolation=\"bilinear\")\n    # plt.axis(\"off\")\n    # plt.show()\n\n    wc.to_file(img_file.split('.')[0] + '_wc.png')\n\n\nif __name__ == '__main__':\n    keyword = 'shida'\n    mblogs = json.loads(open('result_{}.json'.format(keyword), 'r', encoding='utf-8').read())\n    print('微博总数：', len(mblogs))\n\n    words = []\n    for blog in mblogs:\n        words.extend(jieba.analyse.extract_tags(blog['text']))\n\n    print(\"总词数：\", len(words))\n    print(words)\n    gen_img(words, 'love.jpg')\n\n\n```\n效果图\n\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180905/EhLH9dKA6g.png?imageslim)\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180905/02i70841eb.png?imageslim)","tags":["编程语言"]},{"title":"Python小实践   下载漫画","url":"/2018/06/12/爬取前准备/","content":"\n# 爬取前准备\n[GitHub项目](https://github.com/lovemefan/python_tools)\n目标网站:[http://www.omanhua.com/comic/17521/](http://www.omanhua.com/comic/17521/)\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180612/jm0j3bkaiB.png?imageslim)\n## 分析网页\n```html\n<div class=\"subBookList\">\n<ul>\n    <li>\n        <a href='/comic/17521/366691/' title='332' target='_blank' class='new'>332</a>\n    </li>\n    <li>\n        <a href='/comic/17521/364901/' title='331' target='_blank' class='new'>331</a>\n    </li>\n    <li>\n        <a href='/comic/17521/364900/' title='腾讯动漫6周年福利活动！' target='_blank' class='new'>腾讯动漫6周年福利活动！</a>\n    </li>\n    <li>\n        <a href='/comic/17521/364899/' title='330。他们也是我们' target='_blank' class='new'>330。他们也是我们</a>\n    </li>\n    <li>\n    <a href='/comic/17521/364730/' title='329' target='_blank' class='new'>329</a>\n    </li>\n\t...\n</ul>\n```\n这里很明显 每个&lta&gt标签的href属性的值就是具体每一话的url\n先点进一话的页面看看\n[http://www.omanhua.com/comic/17521/366691/](http://www.omanhua.com/comic/17521/366691/)\n## 抓包分析\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180612/aJDLmKLIc8.png?imageslim)\n哈哈,没错这个,这是当前显示的一张漫画.但是只有一张.再看看下一张\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180612/iij3m7cKh7.png?imageslim)\n对比URL路径,我特么..,没有丝毫规律,陷入了僵局...,于是没有了后文.\n\n我就像看个漫画嘛,要不是腾讯收费,我&*%^*&%.\n但我还没有放弃,我打算看看js代码里有没有请求什么的痕迹\n就在我垂头顿足的时候,我发现了再网页里的一段神奇的代码\n```html\n<script type=\"text/javascript\">  var pVars = pVars || {}; var uzmh = uzmh || {};eval(function(p,a,c,k,e,d)\n{\n\te=function(c){return(c\n    <a?\"\":e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};\n\tif(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];\n\t\te=function(){return'\\\\w+'};c=1;};\n\twhile(c--)\n\t\tif(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);\n\treturn p;\n}('h i={\"g\":1,\"e\":\"4\",\"f\":\"1.0\",\"m\":\"/n/1/2/l.j\",\"k\":2,\"6\":\"3\",\"7\":[\"8.0\",\"c.0\",\"5.0\",\"b.0\",\"9.0\",\"a.0\",\"d.0\",\"o.0\",\"D.0\",\"E.0\",\"C.0\",\"A.0\",\"B.0\",\"I.0\",\"J.0\",\"H.0\",\"F.0\",\"G.0\",\"z.0\",\"s.0\",\"t.0\",\"r.0\"],\"p\":q,\"x\":y,\"w\":\"/u/v/4/3/\"}||{};\n',46,46,'jpg|17521|366691|332|一人之下|388594b38e|cname|files|38ba1443ba|38f89724c3|381bce4fb2|3886aef5b2|38b823d13d|3857d21ce5|bname|bpic|bid|var|cInfo|html|cid|index|burl|comic|38779d6852|finished|false|3971856aff|399a8af80e|39cc4b3915|tu|undefined|path|len|22|39f92a9dae|387ed1275c|38e5f2512a|385573db27|387ab75347|3866af1df0|38d7d1fc53|382c0123f1|386a165c3e|3859ad824b|38e85b3b5a'.split('|'),0,{}))\n\n</script>\n```\n## 小有成就\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180612/G5L5cHjgFf.png?imageslim)\n通过一比对\n哇!!!我抑制不住内心的激动,这不就是图片名吗?\n以上代码为例,包含了漫画编号(17521),漫画集数编号(36691),漫画集数(332),漫画名(一人之下),当前集的漫画图片数(len=22),以及每张图片的文件名(比如38ba1443ba.jpg)\n大功告成!!!\n# 爬取图片\n## 思路\n有之前准备已经可以再页面上得到每一话的URL,每一话中的图片URL,剩下的就是对页面里的数据提取,分别下载了\n## python 代码\n```python\n# -*- codeing: utf-8 -*-\n# @Time:2018/3/13 22:20\n# @Author:lovemefan\n# @File:一人之下漫画爬虫.py\n# @Software:PyCharm\nimport os\nfrom imp import reload\nimport re\nimport requests as requests\nfrom urllib.request import urlretrieve\n\nrequestSession = requests.session()\n# 保存一张图片\n# 输入参数imgUrl 图片路径,imgPath 保存路径\ndef savePicture(imgUrl, imgPath):\n    response = requests.get(imgUrl)\n    codimg = response.content\n    fn = open(imgPath, 'wb')\n    fn.write(codimg)\n    fn.close()\n\n# 一人之下的漫画路径\nurl = \"http://www.omanhua.com/comic/17521/\"\nhtml = requests.get(url)\nhtml.encoding = 'UTF-8'\n# print(html.text)\n# 先获取每一话\n# 先将数据块取出\nbookListBlock = re.findall(r'<div class=\"subBookList\">(.*?)</div></div>', html.text, re.S)\n# booklist 为每一话的URL的列表\nbookList = re.findall(\"</a></li><li><a href='(.*?)' title='(.*?)'\", bookListBlock[0],re.S)\n\n# 逐话操作\nfor index in bookList:\n    indexUrl = \"http://www.omanhua.com/\"+index[0]+'index.html'\n    indexHtml = requests.get(indexUrl)\n    indexHtml.encoding = 'UTF-8'\n    print(indexHtml.url)\n    # 获得当前话的每张图片路径\n    picList = re.findall(\"一人之下\\|(.*?)'\\.\", indexHtml.text)[0].split('|')\n    #删去piclist无用的信息\n    for item in picList[:]:\n        if item.__len__() != 10:\n            picList.remove(item)\n\n    print(index[1]+'共有%d页'%picList.__len__())\n    picUrlRoot = u'http://pic.fxdm.cc/tu/undefined/一人之下/'\n    # 指定存储位置\n    location = \"J:/一人之下\"\n    # 分开放图片\n    # for page in range(len(picList)):\n    #     if not os.path.exists(\"%s/%s/\"%(location,index[1])):\n    #         os.makedirs(\"%s/%s/\"%(location,index[1]))\n    #     picUrl = picUrlRoot+ index[1]+'/'+picList[page]+'.jpg'\n    #     path = \"%s/%s/%d.jpg\"%(location,index[1],page)\n    #     picUrl.encode('UTF-8')\n    #     #不下载已经下载过的图片,便于更新\n    #     if not os.path.exists(path):\n    #         savePicture(picUrl,path)\n    #         print(picUrl + ' 保存到了 ' + path)\n    #\n\n    # 一起放图片\n    if not os.path.exists(location):\n        os.makedirs(location)\n    for page in range(len(picList)):\n        picUrl = picUrlRoot+ index[1]+'/'+picList[page]+'.jpg'\n        path = \"%s/%s_%d.jpg\"%(location,index[1],page)\n        picUrl.encode('UTF-8')\n        # 不下载已经下载过的图片,便于更新\n        if not os.path.exists(path):\n            savePicture(picUrl,path)\n            print(picUrl + ' 保存到了 ' + path)\n\n\n\n```\n如果想要图片分开放,取消掉注释的代码,注释掉后面一段代码\n\n## 结果\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180612/idJgkeGKgi.png?imageslim)\n### 分开放\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180612/8iDf2611JC.png?imageslim)\n### 一起放\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180612/J4gh2Gb514.png?imageslim)\n\n我要去看漫画了,不要打扰我(/≧▽≦)/~┴┴ \n\n## [`源码在这`](https://github.com/lovemefan/python_tools/blob/master/%E6%BC%AB%E7%94%BB/%E4%B8%80%E4%BA%BA%E4%B9%8B%E4%B8%8B%E6%BC%AB%E7%94%BB%E7%88%AC%E8%99%AB.py)\n\n\n","tags":["编程语言"]},{"title":"Python小实践   微博爬虫","url":"/2018/05/28/抓取女神微博动态并保存到数据库/","content":"\n# 抓取女神微博动态并保存到数据库\n\n偶少有刷微博,常常错过女神的动态.微博客户端也常常不给我推送动态,于是我想自己给自己推送,而且还想把数据保存到自己的数据库里,于是有了接下来的尝试\n## 使用chrome浏览器抓包\n这里随便用什么软件都可以,目的只是抓包.本人使用chrome抓包\n按下F12,查看这两个getindex的数据包\n需要获得两个参数`uid`和`containerid`\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180528/7HhB9BliF2.png?imageslim)\t\n这里需要通过手机版weibo http://m.weibo.com来进行模拟请求，不是通过分析html代码再通过筛选来完成数据抓取。\n笔者先用postmen软件模拟一次post请求,返回结果如下\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180528/8c54K4H2E1.png?imageslim)\n返回的是json数据,接下来就是处理数据了\n## 模拟请求\n以下是python模拟的post请求\n``` python\nimport requests\nimport json\nimport pymysql\ncursor = db.cursor()\nurl=\"https://m.weibo.cn/api/container/getIndex\"\nfor k in range(10):\n    # 用户的uid,containerid,以及页数.每页最多为十条记录\n    payload={'type':'uid','value':'56xxxxxx00','containerid':'1076xxxxxxxx5400','page': '%d'%page}\n    r=requests.post(url,data=payload)\n    raw_text=r.text\n    d=json.loads(raw_text)\n``` \n由于每页只有最新的十条记录,所以需要把每一页的数据都存起来\n\n## 数据库建表\n笔者选择了一些基本信息存储,并没有保存评论信息.其中包括\n* itemid 每条微博的ID\n* scheme 每条微博的跳转链接(方便查看)\n* id 也是用于表示每条微博的ID,具体与itemid的区别笔者未深究\n* created_at 发微博的时间,精确到天\n* text 微博内容\n* source 微博来源,比如手机型号\n* user_id 发微博的用户ID \n``` sql\nSET FOREIGN_KEY_CHECKS=0;\n\n-- ----------------------------\n-- Table structure for mblog\n-- ----------------------------\nDROP TABLE IF EXISTS `mblog`;\nCREATE TABLE `mblog` (\n  `itemid` varchar(40) NOT NULL,\n  `scheme` varchar(100) DEFAULT NULL,\n  `id` varchar(20) DEFAULT NULL,\n  `created_at` varchar(10) DEFAULT NULL,\n  `text` text,\n  `source` varchar(20) DEFAULT NULL,\n  `user_id` varchar(20) DEFAULT NULL,\n  PRIMARY KEY (`itemid`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n  \n```\n## 分析数据并插入表中\n这里直接贴代码了,代码有详细注释\n```python\n# -*- codeing: utf-8 -*-\n# @Time:2018/5/28 14:31\n# @Author:lovemefan\n# @File:抓取女神微博动态保存到数据库.py\n# @Software:PyCharm\n#\n#原始URL:https://m.weibo.cn/p/100xxxxxxxx15400\nimport requests\nimport json\nimport pymysql\n# 打开数据库连接\ndb = pymysql.connect(\"localhost\", \"账号\", \"密码\", \"数据库名\", charset='utf8')\n# 使用cursor()方法获取操作游标\ncursor = db.cursor()\nurl=\"https://m.weibo.cn/api/container/getIndex\"\npage = 1\nsum = 0\nfor k in range(35):\n    # 用户的uid,containerid,以及页数.每页最多为十条记录\n    payload={'type':'uid','value':'56xxxxxx00','containerid':'10760xxxxxxxx400','page': '%d'%page}\n    r=requests.post(url,data=payload)\n    raw_text=r.text\n    d=json.loads(raw_text)\n    try:\n        for i in range(10):\n            print(\"第%d页第%d条\"% (page,i))\n            print(d[\"data\"][\"cards\"])\n            itemid = str(d[\"data\"][\"cards\"][i][\"itemid\"])\n            scheme = str(d[\"data\"][\"cards\"][i][\"scheme\"])\n            id = str(d[\"data\"][\"cards\"][i][\"mblog\"][\"id\"])\n            create_at = str(d[\"data\"][\"cards\"][i][\"mblog\"][\"created_at\"])\n            #将内容中的单引号换成双引号,否则插入数据库中会报错\n            text = str(d[\"data\"][\"cards\"][i][\"mblog\"][\"text\"]).replace(\"'\",\"\\\"\")\n            source = str(d[\"data\"][\"cards\"][i][\"mblog\"][\"source\"])\n            user_id = str(d[\"data\"][\"cards\"][i][\"mblog\"][\"user\"][\"id\"])\n            # sql插入语句\n            sql = \"insert ignore into mblog(itemid,scheme,id,created_at,text,source,user_id) VALUES('%s','%s','%s','%s','%s','%s','%s')\" % (itemid,scheme,id,create_at,text,source,user_id)\n            print(sql)\n            # 执行sql语句\n            cursor.execute(sql)\n            # 执行sql语句\n            db.commit()\n            sum = sum + 1\n    except IndexError:\n        # 但记录不满10条的时候,捕获list越界异常,自动跳过\n        pass\n\n    page = page + 1\n    print(\"第%d页执行成功\"%page)\n        # print([\"text\"])\ndb.close()\nprint(\"一共插入了%d的条记录\"% sum)\n```\n## 结果\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180528/ICjHHa2I31.png?imageslim)\n保存成功,然后就可以去翻数据库里的数据了.\n## 缺陷\n* 只能一次性的保存至今的记录,后续添加监听并邮箱推送\n* 后续可以添加数据分析,关键子词云","tags":["编程语言"]},{"title":"Android学习笔记 (三)   MP3播放器","url":"/2017/11/12/MP3播放器/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n 利用Intent 唤醒其他Activity或其他APP\n<!-- more -->\n<The rest of contents | 余下全文>\n# MP3播放器\n整个音乐播放器设计模仿网易云音乐风格\n工程源代码已上传至Github: [源码下载](https://github.com/lovemefan/MP3Player)\n\n**实现的功能**:\n* **1.**暂停,开始音乐,后台播放\n* **2.**进度条可拖动,能实现音乐跳转\n* **3.**能够循环切换上一曲和下一曲\n* **4.**播放完毕后自动下一曲\n* **5.**歌曲封面有旋转的动画\n* **6.**背景图片毛玻璃美化\n\n**待实现的功能**\n* 音乐列表\n* 本地音乐读取播放\n* 网络音乐播放\n\n## Music.java设计\n要播放多首音乐,首先设计一个音乐类用于存放歌曲信息,如歌曲名,封面图片的ID,音乐文件的ID\n`Music.java`\n```java\npackage com.lovemefan.mp3player;\n\nimport android.os.Bundle;\nimport android.os.Parcel;\nimport android.os.Parcelable;\n\n\n/**\n * Created by Lovemefan on 2017/11/7.\n */\n\npublic class Music implements Parcelable{\n    private String name;//歌曲名\n    private int coverId;//封面的ID\n    private int resourceId;//资源路径ID\n    public Music(String name, int coverId, int resourceId) {\n        this.name = name;\n        this.coverId = coverId;\n        this.resourceId = resourceId;\n    }\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getCoverId() {\n        return coverId;\n    }\n\n    public void setCoverId(int coverId) {\n        this.coverId = coverId;\n    }\n\n    public int getResourceId() {\n        return resourceId;\n    }\n\n    public void setResourceId(int resourceId) {\n        this.resourceId = resourceId;\n    }\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n//    实现接口Parcelable需要重写下面两个方法\n    @Override\n    public void writeToParcel(Parcel parcel, int i) {\n        parcel.writeString(getName());\n        Bundle bundle = new Bundle();\n        bundle.putInt(\"coverId\",getCoverId());\n        bundle.putInt(\"resourceId\",getResourceId());\n        parcel.writeBundle(bundle);\n    }//将成员变量一一写入Parcel中\n    public static final Creator<Music> CREATOR = new Creator<Music>() {\n        @Override\n        public Music createFromParcel(Parcel parcel) {\n            Bundle bundle = parcel.readBundle();\n            return new Music(parcel.readString(), bundle.getInt(\"coverId\"), bundle.getInt(\"resourceId\"));\n        }\n\n        @Override\n        public Music[] newArray(int i) {\n            return new Music[i];\n        }\n    };\n}\n```\n## 后台服务类\n为了让音乐能够在app后台运行,就要设计一个Service.\n`MusicPlayService.java`\n```java\npackage com.lovemefan.mp3player;\n\nimport android.app.Service;\nimport android.content.Intent;\nimport android.media.MediaPlayer;\nimport android.os.Binder;\nimport android.os.IBinder;\n\nimport java.util.ArrayList;\n\npublic class MusicPlayService extends Service {\n    private MediaPlayer mediaPlayer = null;\n    public MusicPlayService() {\n    }\n    class MyBinder extends Binder{\n        public MediaPlayer getMediaPlayer(){\n            return mediaPlayer;\n        }\n    }\n    @Override\n    public IBinder onBind(Intent intent) {\n        // TODO: Return the communication channel to the service.\n        return new MyBinder();\n    }\n    @Override\n    public void onCreate() {\n        mediaPlayer = MediaPlayer.create(this,R.raw.aimer_ninelie);//设置初始值\n//        mediaPlayer.start();\n        super.onCreate();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n    }\n}\n```\n##  MainActivity.java\n由MainActivity绑定MusicPlayService服务,让音乐在服务中运行.另外还要创建一个线程来更新进度条和当前时间.\n`MainActivity.java`\n```java\npackage com.lovemefan.mp3player;\n\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.res.AssetFileDescriptor;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.media.AudioAttributes;\nimport android.media.MediaPlayer;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.support.annotation.RequiresApi;\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.view.animation.LinearInterpolator;\nimport android.view.animation.RotateAnimation;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\n\n\npublic class MainActivity extends AppCompatActivity implements ServiceConnection {\n    ArrayList<Music> musics = new ArrayList<>();\n    MediaPlayer mediaPlayer;//媒体播放器\n    ImageView playButton;//播放按钮\n    SeekBar progressBar ;//进度条\n    TextView title;//标题,用于显示歌名\n    TextView currentTime;//显示当前播放的时间\n    TextView duration;//显示歌曲时长\n    Handler handler ;//用于其他线程更新\n    CircleImageView cover;//显示歌曲的封面\n    LinearLayout root;//根面板\n    int musicProcess=0;//歌曲的进度;\n    int musicCurIndex = 0;//当前播放的歌曲的下标\n    Animation rotateAnimation ;\n\n    //用于handle的handleMessage处理不同的事件\n    static final int UpdateCurrentTime=0;//刷新当前播放时间标识符\n    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        supportRequestWindowFeature(Window.FEATURE_NO_TITLE);;//去掉标题栏\n        this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);//去掉信息栏\n        setContentView(R.layout.activity_main);\n        activityInit();//相关控件初始化\n        bindService(new Intent(MainActivity.this,MusicPlayService.class), MainActivity.this, Context.BIND_AUTO_CREATE);//绑定服务\n\n        musics.add(new Music(\"ninelie\",R.drawable.nineliecover,R.raw.aimer_ninelie));\n        musics.add(new Music(\"像风一样\",R.drawable.linkwinds,R.raw.like_winds));\n        musics.add(new Music(\"Let It Out\",R.drawable.let_it_out,R.raw.let_it_out));\n        refreshMusicInfo(musics.get(0));\n        //\n        progressBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\n            @Override\n            public void onProgressChanged(SeekBar seekBar, int i, boolean b) {\n                musicProcess = i;\n                //自动播放下一曲\n                if(mediaPlayer.getDuration() - musicProcess < 500){\n                    musicCurIndex = (musicCurIndex + 1) % musics.size();\n                    refreshMusicInfo(musics.get(musicCurIndex));\n                    play();//播放音乐\n                }\n            }\n\n            @Override\n            public void onStartTrackingTouch(SeekBar seekBar) {\n\n            }\n\n            @Override\n            public void onStopTrackingTouch(SeekBar seekBar) {\n                mediaPlayer.seekTo(musicProcess);//跳转到\n            }\n        });\n\n        handler = new Handler(new Handler.Callback(){\n        @Override\n        public boolean handleMessage(Message message) {\n            switch (message.what){\n                case UpdateCurrentTime:currentTime.setText(secondsToMinutes(mediaPlayer.getCurrentPosition()));break;\n            }\n            return true;\n        }\n        });\n        findViewById(R.id.playButton).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                play();\n            }\n        });\n\n    }\n    public void activityInit(){\n        playButton = (ImageView) findViewById(R.id.playButton);\n        progressBar = ( SeekBar) this.findViewById(R.id.progressBar);\n        currentTime = (TextView) findViewById(R.id.curTime);\n        duration = (TextView) findViewById(R.id.duration);\n        title = (TextView) findViewById(R.id.musicName);\n        cover = (CircleImageView) findViewById(R.id.musicCover);\n        root = (LinearLayout) findViewById(R.id.root);\n        rotateAnimation =  AnimationUtils.loadAnimation(this,R.anim.rotation);\n        rotateAnimation.setFillEnabled(true);\n        rotateAnimation.setFillAfter(true);\n        rotateAnimation.setInterpolator(new LinearInterpolator());\n\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unbindService(MainActivity.this);\n    }\n\n    @Override\n    public void onServiceConnected(ComponentName componentName, IBinder iBinder) {\n        System.out.println(\"绑定成功\");\n        mediaPlayer = ((MusicPlayService.MyBinder)iBinder).getMediaPlayer();\n        progressBar.setMax(mediaPlayer.getDuration());//设置进度条\n        duration.setText(\"\"+secondsToMinutes(mediaPlayer.getDuration()));\n        currentTime.setText(\"00:00\");\n        System.out.println(mediaPlayer.getDuration());\n\n    }\n\n    @Override\n    public void onServiceDisconnected(ComponentName componentName) {\n\n    }\n    public String secondsToMinutes(int seconds){\n        int minute = seconds/60000;\n        int second = (seconds/1000)%60;\n        String  m = \"\"+ minute;\n        String  s = \"\" + second;\n        if (minute<10){\n            m = \"0\" + minute;\n        }\n        if(second<10){\n           s = \"0\" + second;\n        }\n        return m + \":\" + s;\n    }\n\n    public void play() {\n        if(mediaPlayer == null ){\n            System.out.println(\"mediaplayer初始化失败\");\n        }else{\n            if(mediaPlayer.isPlaying()){\n                mediaPlayer.pause();\n                cover.clearAnimation();\n                playButton.setImageResource(R.drawable.play);\n            }else{\n                mediaPlayer.start();\n\n                cover.startAnimation(rotateAnimation);\n                playButton.setImageResource(R.drawable.pause);\n            }\n            System.out.println(mediaPlayer.isPlaying());\n            new MyThread().start();\n        }\n    }\n    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n    public void refreshMusicInfo(Music curMusic){\n        title.setText(curMusic.getName());//设置歌曲名\n        //        获取需要被模糊的原图bitmap\n        Resources res = getResources();\n        Bitmap scaledBitmap = BitmapFactory.decodeResource(res, curMusic.getCoverId());\n        //        scaledBitmap为目标图像，25是缩放的倍数（越大模糊效果越高）\n        Bitmap blurBitmap = BlurImage.toBlur(scaledBitmap, 50);\n        root.setBackground(new BitmapDrawable(blurBitmap));//设置根面板背景\n        cover.setImageResource(curMusic.getCoverId());//设置封面\n        if(mediaPlayer == null){\n            System.out.println(\"mediaplayer初始化失败\");\n        }else{\n            try {\n                AssetFileDescriptor afd = this.getResources().openRawResourceFd(curMusic.getResourceId());\n                if (afd == null) {\n                    Toast.makeText(this,\"音乐打开失败\",Toast.LENGTH_SHORT).show();\n                }else{\n                    mediaPlayer.stop();\n                    final AudioAttributes aa = new AudioAttributes.Builder().build();\n                    mediaPlayer.setAudioAttributes(aa);\n                    mediaPlayer.setAudioSessionId(mediaPlayer.getAudioSessionId() + 1);\n                    mediaPlayer.setDataSource(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength());//设置音乐源\n                    afd.close();//关闭文件\n                    mediaPlayer.prepare();//音乐准备\n                }\n            } catch (IOException e) {\n                Toast.makeText(this,\"音乐播放失败\",Toast.LENGTH_SHORT).show();\n            }\n                currentTime.setText(\"00:00\");//设置开始时间\n                duration.setText(secondsToMinutes(mediaPlayer.getDuration()));//获取音乐时长,并设置时间\n                progressBar.setProgress(0);//将播放进度条清零\n                playButton.setImageResource(R.drawable.play);//重新将按钮设置为播放\n            }\n        }\n\n    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n    public void previouMusic(View view) {\n        //可实现循环切换\n        musicCurIndex = (musicCurIndex + musics.size() -1) % musics.size() ;//加上music.size()防止出现负数\n        refreshMusicInfo(musics.get(musicCurIndex));\n        play();\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n    public void nextMusic(View view) {\n        //可实现循环切换\n        musicCurIndex = (musicCurIndex + 1) % musics.size();\n        refreshMusicInfo(musics.get(musicCurIndex));\n        play();\n    }\n\n    class MyThread extends Thread{\n        public  void run(){\n            while(mediaPlayer.isPlaying()){\n                progressBar.setMax(mediaPlayer.getDuration());\n                progressBar.setProgress(mediaPlayer.getCurrentPosition());\n                handler.sendMessage(Message.obtain());\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n## 界面设计\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"com.lovemefan.mp3player.MainActivity\">\n\n    <LinearLayout\n        android:id=\"@+id/root\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\"\n        android:orientation=\"vertical\"\n        >\n\n        <LinearLayout\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"0dp\"\n            android:layout_weight=\"1\"\n            android:alpha=\"0.4\"\n            android:background=\"#3c3c3c\"\n            android:orientation=\"horizontal\">\n\n            <TextView\n                android:id=\"@+id/musicName\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:layout_weight=\"1\"\n                android:textAlignment=\"center\"\n                android:textColorHighlight=\"@color/colorAccent\"\n                android:textStyle=\"bold\"\n                android:textColor=\"#fff\"\n                android:textSize=\"18pt\" />\n        </LinearLayout>\n\n        <LinearLayout\n            android:id=\"@+id/centerArea\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"0dp\"\n            android:layout_weight=\"7.5\"\n            android:orientation=\"vertical\">\n\n            <RelativeLayout\n                android:layout_width=\"fill_parent\"\n                android:layout_height=\"fill_parent\"\n                android:layout_marginBottom=\"20dp\">\n\n                <ImageView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:layout_centerHorizontal=\"true\"\n                    android:layout_centerInParent=\"true\"\n                    android:layout_centerVertical=\"true\"\n                    android:src=\"@drawable/record\" />\n\n                <com.lovemefan.mp3player.CircleImageView xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n                    android:id=\"@+id/musicCover\"\n                    android:layout_width=\"225dp\"\n                    android:layout_height=\"225dp\"\n                    android:src=\"@drawable/nineliecover\"\n                    app:civ_border_color=\"#3c3c3c\"\n                    app:civ_border_width=\"2dp\"\n                    android:layout_centerHorizontal=\"true\"\n                    android:layout_centerInParent=\"true\"\n                    android:layout_centerVertical=\"true\"\n                    />\n            </RelativeLayout>\n\n            <LinearLayout\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"20dp\"\n                android:layout_marginTop=\"-20dp\"\n                android:orientation=\"horizontal\">\n\n                <TextView\n                    android:id=\"@+id/curTime\"\n                    android:layout_width=\"0pt\"\n                    android:layout_height=\"match_parent\"\n                    android:textAlignment=\"center\"\n                    android:layout_weight=\"1.2\" />\n\n                <SeekBar\n                    android:id=\"@+id/progressBar\"\n                    style=\"?android:attr/progressBarStyleHorizontal\"\n                    android:layout_width=\"0dp\"\n                    android:layout_height=\"match_parent\"\n                    android:layout_weight=\"7.6\" />\n\n                <TextView\n                    android:id=\"@+id/duration\"\n                    android:layout_width=\"0dp\"\n                    android:layout_height=\"match_parent\"\n                    android:layout_weight=\"1.2\" />\n\n            </LinearLayout>\n\n\n        </LinearLayout>\n\n        <LinearLayout\n            android:id=\"@+id/playBar\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"0dp\"\n            android:layout_weight=\"1.5\"\n            android:alpha=\"0.4\"\n            android:background=\"#3c3c3c\"\n            android:orientation=\"horizontal\">\n\n            <ImageView\n                android:id=\"@+id/previouButton\"\n                android:layout_width=\"60dp\"\n                android:layout_height=\"60dp\"\n                android:layout_marginTop=\"10dp\"\n                android:layout_weight=\"2\"\n                android:onClick=\"previouMusic\"\n                app:srcCompat=\"@drawable/previous\" />\n\n            <ImageView\n                android:id=\"@+id/playButton\"\n                android:layout_width=\"60dp\"\n                android:layout_height=\"60dp\"\n                android:layout_marginTop=\"10dp\"\n                android:layout_weight=\"2\"\n                app:srcCompat=\"@drawable/play\" />\n\n            <ImageView\n                android:id=\"@+id/nextButton\"\n                android:layout_width=\"60dp\"\n                android:layout_height=\"60dp\"\n                android:layout_marginTop=\"10dp\"\n                android:layout_weight=\"2\"\n                android:onClick=\"nextMusic\"\n                app:srcCompat=\"@drawable/next\" />\n        </LinearLayout>\n\n    </LinearLayout>\n</android.support.constraint.ConstraintLayout>\n```\n\n## 界面效果\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/171116/dlca6h3hAD.png?imageslim)\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/171116/0GCA5kkBc2.png?imageslim)\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/171116/hKd52055A0.png?imageslim)\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/171116/jbaI2K4LC3.png?imageslim)","tags":["学习笔记"]},{"title":"Android学习笔记 (二)   Intent唤醒其他Activity或APP","url":"/2017/10/20/Android 如何唤醒第三方APP/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n 利用Intent 唤醒其他Activity或其他APP\n<!-- more -->\n<The rest of contents | 余下全文>\n# Android 如何唤醒第三方APP\n## Intent类的通常用法\n### `1.启动 Activity：`\n\n>Activity 表示应用中的一个屏幕。通过将 Intent 传递给 startActivity()，您可以启动新的 Activity 实例。Intent 描述了要启动的 Activity，并携带了任何必要的数据。 \n如果您希望在 Activity 完成后收到结果，请调用 startActivityForResult()。在 Activity 的 onActivityResult() 回调中，您的 Activity 将结果作为单独的 Intent 对象接收。如需了解详细信息，请参阅 Activity 指南。\n\n### `2.启动服务：`\n\n>Service 是一个不使用用户界面而在后台执行操作的组件。通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 描述了要启动的服务，并携带了任何必要的数据。 \n如果服务旨在使用客户端-服务器接口，则通过将 Intent 传递给 bindService()，您可以从其他组件绑定到此服务。如需了解详细信息，请参阅服务指南。\n\n### `3.传递广播：`\n\n>广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 Intent 传递给 sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast()，您可以将广播传递给其他应用。\n\n### `以下内容只讨论启动Activity`\n## Intent 启动Activity\n### 1.启动Activity\n`代码示例:`\n```java\n//调用系统默认浏览器打开百度\n    public void openBaidu(View view) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.setData(Uri.parse(\"http://www.baidu.com\"));//设置url\n        startActivity(intent);\n    }\n    //调用系统电话,拨打10086.需要添加权限\n    public void openCall(View view) {\n        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) {\n            // TODO: Consider calling\n            //    ActivityCompat#requestPermissions\n            // here to request the missing permissions, and then overriding\n            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,\n            //                                          int[] grantResults)\n            // to handle the case where the user grants the permission. See the documentation\n            // for ActivityCompat#requestPermissions for more details.\n            return;\n        }\n        startActivity(new Intent(Intent.ACTION_CALL, Uri.parse(\"tel:10086\")));\n    }\n    //调用系统信息应用\n    public void openSms(View view) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.setType(\"vnd.android-dir/mms-sms\");\n        intent.putExtra(\"sms_body\",\"\"); //第二个参数为短信内容\n        startActivity(intent);\n    }\n    //打开QQ,uin=10000为打开qq10000的用户的聊天界面\n    public void openQQ(View view) {\n        EditText editText = (EditText)findViewById(R.id.editText);\n        startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(\"mqqwpa://im/chat?chat_type=wpa&uin=\"+ editText.getText()+\"&version=1\")));\n    }\n    //打开系统相机\n    public void openCamera(View view) {\n        startActivity(new Intent(\"android.media.action.STILL_IMAGE_CAMERA\"));\n    }\n    //打开微信\n    public void openWechat(View view) {\n        Intent intent = new Intent();\n        ComponentName cmp = new ComponentName(\"com.tencent.mm\",\"com.tencent.mm.ui.LauncherUI\");\n        intent.setAction(Intent.ACTION_MAIN);\n        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        intent.setComponent(cmp);\n        startActivityForResult(intent, 0);\n\n\n    }\n    //打开新浪微博\n    public void openBlog(View view) {\n        Intent intent = new Intent();\n        ComponentName cmp = new ComponentName(\"com.sina.weibo\",\"com.sina.weibo.SplashActivity\");\n        intent.setAction(Intent.ACTION_MAIN);\n        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        intent.setComponent(cmp);\n        startActivityForResult(intent, 0);\n    }\n```\n`以上代码主要用了两种方法设置将要跳转的Activity的信息,第一个是设置Uri,第二种是设置Component来实现跳转`\n### 2.启动APP\n对于第三方APP,笔者主要采用设置`Component`的方法\n\n\n在监听器或其他区域,输入以下代码\n\n```java\n\t\tIntent intent = new Intent();\n\t\t//ComponentName(String psk,String cls)\n\t\t//PKG的组件存在的包的名字。不能为空。CLS的PKG实现组件的内部类的名字。不能为空。\n        ComponentName cmp = new ComponentName(\"com.tencent.mm\",\"com.tencent.mm.ui.LauncherUI\");//启动微信\n        intent.setAction(Intent.ACTION_MAIN);\n        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        intent.setComponent(cmp);\n        startActivityForResult(intent, 0);\n```\n\n## 一些安卓应用的pkg和cls\n`以下的APP都是根据笔者的当前手机的app导出得到的,所以只有部分常用的应用`\n导出App信息(pkg和cls)项目:[https://github.com/lovemefan/PackageMangerDemo](https://github.com/lovemefan/PackageMangerDemo) \n|应用|pkg |cls |\n|:--------|:----------:|:--------------:|\n|阿里云|com.alibaba.aliyun|com.alibaba.aliyun.biz.login.WelcomeActivity|\n|爱奇艺|com.qiyi.video|com.qiyi.video.WelcomeActivity|\n|百度贴吧|com.baidu.tieba|com.baidu.tieba.LogoActivity|\n|百度网盘|com.baidu.netdisk|com.baidu.netdisk.ui.Navigate|\n|备忘录|com.samsung.android.app.memo|com.samsung.android.app.memo.Main|\n|哔哩哔哩|tv.danmaku.bili|tv.danmaku.bili.ui.splash.SplashActivity|\n|车来了|com.ygkj.chelaile.standard|dev.xesam.chelaile.app.module.func.SplashActivity|\n|电话|com.android.contacts|com.android.dialer.DialtactsActivity|\n|电子邮件|com.samsung.android.email.provider|com.samsung.android.email.ui.activity.MessageListXL|\n|盖乐世空间|com.samsung.android.voc|com.samsung.android.voc.LauncherActivity|\n|高德地图|com.autonavi.minimap|com.autonavi.map.activity.SplashActivity|\n|高铁管家12306火车票|com.gtgj.view|com.gtgj.view.LaunchActivity|\n|黑域|me.piebridge.brevent|me.piebridge.brevent.ui.BreventActivity|\n|计算器|com.sec.android.app.popupcalculator|com.sec.android.app.popupcalculator.Calculator|\n|交管12123|com.tmri.app.main|com.tmri.app.ui.activity.TmriActivity|\n|京东|com.jingdong.app.mall|com.jingdong.app.mall.main.MainActivity|\n|联系人|com.android.contacts|com.android.contacts.activities.PeopleActivity|\n|猎吧出行|com.example.liabarcarandroid|com.liabarcar.guide.SplashActivity|\n|浏览器|com.sec.android.app.sbrowser|com.sec.android.app.sbrowser.SBrowserMainActivity|\n|录音机|com.sec.android.app.voicenote|com.sec.android.app.voicenote.main.VNMainActivity|\n|南昌航空大学|com.eteasun.nanhang|com.eteasun.nanhang.activity.WelcomeActvity|\n|全民K歌|com.tencent.karaoke|com.tencent.karaoke.module.splash.ui.SplashBaseActivity|\n|三星健康|com.sec.android.app.shealth|com.samsung.android.app.shealth.home.HomeMainActivity|\n|三星生活助手|com.samsung.android.app.sreminder|com.samsung.android.app.sreminder.phone.cardlist.SReminderActivity|\n|三星视频|com.samsung.android.onlinevideo|com.samsung.android.onlinevideo.list.activity.VideoList|\n|三星音乐|com.samsung.android.app.music.chn|com.samsung.android.app.music.common.activity.MusicMainActivity|\n|三星阅读|com.mci.smagazine|com.chaozh.iReader.ui.activity.WelcomeActivity|\n|三星云|com.samsung.multidevicecloud|com.kanbox.wp.Main|\n|扫描全能王|com.intsig.camscanner|com.intsig.camscanner.WelcomeActivity|\n|扇贝单词|com.shanbay.words|com.shanbay.words.startup.SplashActivity|\n|设置|com.android.settings|com.android.settings.Settings|\n|时钟|com.sec.android.app.clockpackage|com.sec.android.app.clockpackage.ClockPackage|\n|手机淘宝|com.taobao.taobao|com.taobao.tao.welcome.Welcome|\n|手机营业厅|com.sinovatech.unicom.ui|com.sinovatech.unicom.ui.WelcomeClient|\n|搜狐视频|com.sohu.sohuvideo|com.sohu.sohuvideo.FirstNavigationActivityGroup|\n|腾讯动漫|com.qq.ac.android|com.qq.ac.android.view.activity.SplashActivity|\n|腾讯课堂|com.tencent.edu|com.tencent.edu.module.SplashActivity|\n|腾讯视频|com.tencent.qqlive|com.tencent.qqlive.ona.activity.WelcomeActivity|\n|通卡宝|com.nci.tkb|com.nci.tkb.ui.SplashActivity|\n|网易有道词典|com.youdao.dict|com.youdao.dict.activity.DictSplashActivity|\n|网易云音乐|com.netease.cloudmusic|com.netease.cloudmusic.activity.LoadingActivity|\n|微博|com.sina.weibo|com.sina.weibo.SplashActivity|\n|微信|com.tencent.mm|com.tencent.mm.ui.LauncherUI|\n|我的文件|com.sec.android.app.myfiles|com.sec.android.app.myfiles.common.MainActivity|\n|闲鱼|com.taobao.idlefish|com.taobao.fleamarket.home.activity.InitActivity.Round|\n|相册|com.sec.android.gallery3d|com.sec.android.gallery3d.app.GalleryOpaqueActivity|\n|相机|com.sec.android.app.camera|com.sec.android.app.camera.Camera|\n|小米VR|com.mi.dlabs.vr.hulk|com.mi.dlabs.vr.hulk.launch.HulkLaunchActivity|\n|信息|com.android.mms|com.android.mms.ui.ConversationComposer|\n|一键锁屏|com.yujing.lockscreen|com.yujing.lockscreen.MainActivity|\n|应用商店|com.sec.android.app.samsungapps|com.sec.android.app.samsungapps.SamsungAppsMainActivity|\n|影梭|com.github.shadowsocks|com.github.shadowsocks.Shadowsocks|\n|优酷|com.youku.phone|com.youku.phone.ActivityWelcome|\n|悦动圈|com.yuedong.sport|com.yuedong.sport.main.WelcomeActivity_|\n|支付宝|com.eg.android.AlipayGphone|com.eg.android.AlipayGphone.AlipayLogin|\n|知乎|com.zhihu.android|com.zhihu.android.app.ui.activity.MainActivity|\n|智能管理器|com.samsung.android.sm|com.samsung.android.sm.app.dashboard.SmartManagerDashBoardActivity|\n|主题商店|com.samsung.android.themestore|com.samsung.android.themestore.activity.Launcher|\n|租八戒|com.rentpig.customer|com.rentpig.customer.main.WelcomeActivity|\n|AChm Free|com.pchen.achmfree|com.pchen.achm.MainActivity|\n|Chrome|com.android.chrome|com.google.android.apps.chrome.Main|\n|ES文件浏览器|com.estrongs.android.pop|com.estrongs.android.pop.app.openscreenad.NewSplashActivity|\n|Excel|com.microsoft.office.excel|com.microsoft.office.apphost.LaunchActivity|\n|Github|com.seasonfif.github|com.seasonfif.github.ui.activity.SplashScreenActivity|\n|IT之家|com.ruanmei.ithome|com.ruanmei.ithome.ui.MainActivity|\n|netkeeper|com.xinli.netkeeper|com.xinli.netkeeper.activitys.WelcomeActivity|\n|ofo共享单车|so.ofo.labofo|so.ofo.labofo.activities.EntryActivity|\n|QQ|com.tencent.mobileqq|com.tencent.mobileqq.activity.SplashActivity|\n|RD Client Beta|com.microsoft.rdc.android.beta|com.microsoft.rdc.ui.activities.HomeActivity|\n|S 换机助手|com.sec.android.easyMover|com.sec.android.easyMover.DistributionActivity|\n|S 日历|com.android.calendar|com.android.calendar.AllInOneActivity|\n|S Voice|com.samsung.voiceserviceplatform|com.samsung.voiceserviceplatform.ui.SVoiceMainActivity|\n|Samsung Gear|com.samsung.android.app.watchmanager|com.samsung.android.app.watchmanager.setupwizard.SetupWizardWelcomeActivity|\n|Super Pads|com.opalastudios.pads|com.opalastudios.pads.ui.MainActivity|\n|Survival Online|com.gameline.survivalcraftfree|com.unity3d.player.UnityPlayerActivity|\n|TapTap|com.taptap|com.play.taptap.ui.MainAct|\n|UC浏览器|com.UCMobile|com.UCMobile.main.UCMobile|\n|USIM卡应用|com.android.stk|com.android.stk.StkLauncherActivity|\n|WiFi万能钥匙|com.snda.wifilocating|com.lantern.launcher.ui.MainActivity|\n|Word|com.microsoft.office.word|com.microsoft.office.apphost.LaunchActivity|","tags":["学习笔记"]},{"title":"Excel 宏命令处理(一)","url":"/2017/10/18/Excel 宏命令处理/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n# Excel 宏命令处理\n&nbsp;&nbsp;&nbsp;&nbsp;在我们工作的时候,常常会遇到大量的数据处理.人工操作费时费力,于是笔者开始百度看看有没有什么自动化的方法,最后发现了excel可以使用宏指令来实现编程式处理.\n## Excel VBA\n>  Visual Basic for Applications(VBA)是Visual Basic的一种宏语言，是微软开发出来在其桌面应用程序中执行通用的自动化(OLE)任务的编程语言。主要能用来扩展Windows的应用程式功能，特别是Microsoft Office软件。也可说是一种应用程式视觉化的Basic 脚本。该语言于1993年由微软公司开发的的应用程序共享一种通用的自动化语言--------Visual Basic For Application(VBA)，实际上VBA是寄生于VB应用程序的版本。微软在1994年发行的Excel5.0版本中，即具备了VBA的宏功能。\n要熟悉VBA，那么就不得不先了解宏和它们之间的关系。\nVBA被称为宏语言，但是它决不能和宏划上等号，宏是一条指令或者几条指令的集合，控制WORD或EXCEL等执行一连串的操作。而VBA则是不折不扣的高级语言，通过面向对象的方法来实现不能实现的功能。在编辑一个宏的时候，visual basic 编辑器会将这个宏记录为一个VBA过程\nVBA使应用程序具有生命的特征，以适应不同的环境，不同的应用，其主要表现为定制、自动化、协作化。\nVBA的特点是将VB语言与应用对象模型结合起来，处理各种应用需求。WORD VBA则是将VB应用于Word对象模型，或者说是用VB语言来操控这些Word对象模型，以达到各种应用的要求。所以，如果你想通过VBA控制WORD或EXCEL，必须同时熟悉VB语言和Word对象模型。\n\n## 如何使用VBA\n`视图-宏`\n![VBA](http://oskhhyaq3.bkt.clouddn.com/blog/171018/hHHBK2h4eh.png?imageslim)\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/171018/F7CBBaFhH3.png?imageslim)\n\n如果不能使用宏,可能你的excel禁用了.启动即可\n启用方式:\n`文件-选项-信任中心-信任中心设置-宏设置-启用所有宏`\n配合录制宏就可以试着写代码了\n\n## Sheet 分割示例\n```vbscript\nSub 自动分类()\n\n' 前提条件:总表已经根据某个要分类的标识字段排好了顺序\n' 此方法是将一张数据量非常大的sheet表按某个字段进行分类并分割成不同的sheet表\n' 同时将该sheet的名称命名为sheet内标识该sheet的字段的名称\n    Dim sheetPage As Integer\n    Dim length As Integer '总表的最后一列的列数\n    Dim i As Integer\n    Dim Name As String\n    Dim topLeft As Integer '所选区域的左上角\n    Dim bottomRight As Integer '所选区域的右下角\n    \n '  参数初始化\n    Name = \"2013\" '总表的名称\n    length = 1510 '总表的最后一列的列数\n    sheetPage = 4 '从第几张sheet开始生成\n    topLeft = 2   '初始从第几列开始\n    bottomRight = 2 '初始从第几列结束\n '\n    '先建表\n        For i = 2 To length\n            Sheets(Name).Select\n            bottomRight = i\n            If Range(\"A\" & topLeft).Value <> Range(\"A\" & bottomRight).Value Then\n                Sheets.Add After:=ActiveSheet\n                topLeft = bottomRight\n            End If\n        Next i\n    '割分\n    \n        topLeft = 2\n        For i = 2 To length\n           Sheets(Name).Select\n           \n           bottomRight = i\n           If Range(\"A\" & topLeft).Value <> Range(\"A\" & bottomRight).Value Then\n                Sheets(Name).Select\n                Range(\"A\" & topLeft & \":\" & \"G\" & (bottomRight - 1)).Select '选择从AtopLeft到Gbottom的区域等待复制\n                Selection.Copy\n                \n                Sheets(sheetPage).Select\n                Range(\"A1\").Select\n                ActiveSheet.Paste\n                Sheets(sheetPage).Name = Range(\"A1\").Value\n                sheetPage = sheetPage + 1\n                topLeft = bottomRight\n           End If\n            \n        Next i\n        \n         Sheets(\"2013\").Select\n         Range(\"A\" & topLeft & \":\" & \"G\" & (bottomRight - 1)).Select\n         Selection.Copy\n         \n         Sheets(sheetPage - 1).Select\n         Sheets.Add After:=ActiveSheet\n         Sheets(sheetPage).Select\n         \n         Range(\"A1\").Select\n         ActiveSheet.Paste\n         sheetName = Range(\"A1\").Value\n         Sheets(sheetPage).Name = sheetName\n         \n         topLeft = bottomRight\n    \n    \n    \nEnd Sub\nSub 排序()\n    For Each Sh In Worksheets\n        If Sh.Index > 4 Then  '限定工作表范围\n            Sh.Select\n            Columns(\"B:B\").Select\n            Sh.Sort.SortFields.Clear\n            Sh.Sort.SortFields.Add Key:=Range(\"B1\"), _\n                SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal\n            With Sh.Sort\n                .SetRange Range(\"A1:G69\")\n                .Header = xlNo\n                .MatchCase = False\n                .Orientation = xlTopToBottom\n                .SortMethod = xlPinYin\n                .Apply\n            End With\n            End If\n        Next\n\n\n\n\nEnd Sub\n\n\n\n```\n## [github源码下载](https://github.com/lovemefan/Excell-Macro)","tags":["宏命令"]},{"title":"Java学习笔记 (一)   基于Robot类的一些自动测试类的一些应用","url":"/2017/10/17/Java Robot类的一些应用/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n# Java Robot类的一些应用\n##  Robot简介\n&nbsp;&nbsp;&nbsp;&nbsp;Robot类是JAVA程序实现自动测试，自动演示功能，或者是其它的一些鼠标和键盘控制的应用。出于这样的目的，自从JDK1.3开始，它就为我们提供了一个用来产生本机输入事件的机器人类－－java.awt.Robot.\n&nbsp;&nbsp;&nbsp;&nbsp;此类本来是通过操作鼠标键盘来完成软件的自动测试使用的,我们可以利用Robot类来实现一些我们想要达到的结果\n\n## Robot API\n[官方英文API](https://docs.oracle.com/javase/7/docs/api/java/awt/Robot.html)\n``Robot类其中的方法:``\n![methods](http://oskhhyaq3.bkt.clouddn.com/blog/171017/17j0LJJLEB.png?imageslim)\n\n\n通过查看API,Robot类提供了`截屏` ` 获取屏幕某一点的像素的颜色``键盘按下和释放事件``鼠标点击和释放事件``鼠标移动事件``鼠标滑轮事件`.\n\n## Demo\n这个demo是来实现模拟键盘的一个例子.实现一个信息轰炸功能.\n点击运行后,将光标移到输入区域,程序运行五秒之后会在光标出不断输出字符.\n其中还要使用到java.awt.event.KeyEvent类中的键值\n代码如下:\n```java\nimport java.awt.AWTException;\nimport java.awt.Robot;\nimport java.awt.event.KeyEvent;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class sendMessage {\n\t\n\tprivate int delayTime;\n\tprivate int range;\n\tRobot robot ;\n\tMap map;\n\tpublic sendMessage(int delayTime,int range)\n\t{\n\t\tthis.delayTime = delayTime;\n\t\tthis.range = range;\n\t}\n\tpublic void send() {\n\t\t//使用map 将控制键盘的常量存起来，好方便取用。\n\t\tmap = new HashMap();\n\t\tmap.put(0, 0x30);//键盘的0\n\t\tmap.put(1, 0x31);//键盘的1\n\t\tmap.put(2, 0x32);\n\t\tmap.put(3, 0x33);\n\t\tmap.put(4, 0x34);\n\t\tmap.put(5, 0x35);\n\t\tmap.put(6, 0x36);\n\t\tmap.put(7, 0x37);\n\t\tmap.put(8, 0x38);\n\t\tmap.put(9, 0x39);\n\t\ttry {\n\t\t\t\trobot = new Robot();\n\t\t\t\trobot.delay(5000);//延迟5秒供你打开编辑器\n\t\t\t\teditContent2();\n\t\t\t\t\n\t\t} catch (AWTException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\t//每隔几毫秒,以及数值的范围\n\t\tsendMessage demo = new sendMessage(1000,200);\n\t\tdemo.send();\n\t}\n\t/*********************************************\n\t *editContent1实验的功能输出从0到Range的一个方法\n   \t ********************************************/\n\tpublic void editContent1()\n\t{\n\t\t//让机器从0数到Range\n\t\tfor (int i = 0; i <= range; i++) {\n\t\t\trobot.delay(this.delayTime);\n\t\t\t// 个位数的处理\n\t\t\tif (i <= 9) {\n\t\t\t\trobot.keyPress((int) map.get(i));\n\t\t\t\trobot.keyRelease((int) map.get(i));\n\t\t\t\trobot.keyPress(KeyEvent.VK_ENTER);\n\t\t\t\trobot.keyRelease(KeyEvent.VK_ENTER);\n\t\t\t}\n\t\t\t// 两位数的处理\n\t\t\tif (i > 9 && i <= 99) {\n\t\t\t\tint a = i / 10;// 十位\n\t\t\t\tint b = i % 10;// 个位\n\t\t\t\trobot.keyPress((int) map.get(a));\n\t\t\t\trobot.keyRelease((int) map.get(a));\n\t\t\t\trobot.keyPress((int) map.get(b));\n\t\t\t\trobot.keyRelease((int) map.get(b));\n\t\t\t\trobot.keyPress(KeyEvent.VK_ENTER);\n\t\t\t\trobot.keyRelease(KeyEvent.VK_ENTER);\n\t\t\t}\n\t\t\t// 三位数的处理\n\t\t\tif (i > 99 && i <= 999) {\n\t\t\t\tint a = i / 100;// 百位\n\t\t\t\tint b = (i % 100) / 10;// 十位\n\t\t\t\tint c = i % 10;// 个位\n\t\t\t\trobot.keyPress((int) map.get(a));\n\t\t\t\trobot.keyRelease((int) map.get(a));\n\t\t\t\trobot.keyPress((int) map.get(b));\n\t\t\t\trobot.keyRelease((int) map.get(b));\n\t\t\t\trobot.keyPress((int) map.get(c));\n\t\t\t\trobot.keyRelease((int) map.get(c));\n\t\t\t\trobot.keyPress(KeyEvent.VK_ENTER);\n\t\t\t\trobot.keyRelease(KeyEvent.VK_ENTER);\n\t\t\t}\n\t\t}\n\t}\n\t/************************************************************************\n\t *editContent2为模拟键盘输入,在英文输入法状态下输出为拼音字母,中文输入法状态下为中文\n   \t ************************************************************************/\n\tpublic void editContent2()\n\t{\n\t\tfor (int i = 0; i < range; i++) {\n\t\t\trobot.delay(this.delayTime/2);\n\t\t\trobot.keyPress(KeyEvent.VK_C);\n\t\t\trobot.keyRelease(KeyEvent.VK_C);\n\t\t\trobot.keyPress(KeyEvent.VK_N);\n\t\t\trobot.keyRelease(KeyEvent.VK_N);\n\t\t\trobot.keyPress(KeyEvent.VK_M);\n\t\t\trobot.keyRelease(KeyEvent.VK_M);\n\t\t\trobot.keyPress(KeyEvent.VK_SPACE);\n\t\t\trobot.delay(this.delayTime/2); //注意,不过不加delay,在按下之母后立即继续按下后续操作会让输入法来不及相应,所以要延迟一小段时间\n\t\t\trobot.keyPress(KeyEvent.VK_ENTER);\n\t\t\trobot.keyRelease(KeyEvent.VK_ENTER);\n\t\t\t\n\t\t}\n\t\t\n\t}\n}\n\n```\n上面有两个方法分别是`editContent1`和`editContent2`,前者仅仅是从键盘输入一些数字,后者是在打开中文输入法的情况下依次输入中文的拼音,模拟人为打字.\n\n运行结果如下:\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/171017/afljFb21L3.png?imageslim)","tags":["Java"]},{"title":"Python学习笔记 (四)  安装scrapy框架","url":"/2017/09/23/scrapy框架/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n安装scrapy框架\n<!-- more -->\n<The rest of contents | 余下全文>\n## scrapy框架\n>Scrapy，Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。\nScrapy吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。它也提供了多种类型爬虫的基类，如BaseSpider、sitemap爬虫等，最新版本又提供了web2.0爬虫的支持。 --百度百科\n\n## 安装准备\n* pip install whell\n* pip install lxml\n* pipi nstall twisted\n* pip install scrapy\n\n## 新建项目\n在控制台下输入:\n* 创建项目: scrapy startproject 项目名      \n* 创建爬虫: scrapy genspider -t basic 爬虫名 目标URL\n\n__项目目录如下:__\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170923/a4l4a8H3eJ.png?imageslim)\n\n## 运行项目\n\n  在控制台下输入: scrapy crawl  爬虫名\n ","tags":["编程语言"]},{"title":"Android学习笔记 (一)   按钮事件处理的五种方法","url":"/2017/09/12/Android 按钮事件的五种处理方法/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n 收集了五种处理按钮事件处理的方法\n<!-- more -->\n<The rest of contents | 余下全文>\n# Android 按钮事件的五种处理方法\n这里用一个小例子来说明:\n首先在新建的工程的activity_main.xml中添加一个Button和一个TextView.\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<android.support.constraint.ConstraintLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"com.lovemefan.myapplication3.MainActivity\">\n\n    <TextView\n        android:id=\"@+id/tv1\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World!\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n    <Button\n        android:id=\"@+id/bt1\"\n        android:text=\"click\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n</android.support.constraint.ConstraintLayout>\n\n```\n## `1.使用匿名内部类`\n接下来在MainActivity.java文件中如下\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button bt = (Button) findViewById(R.id.bt1);\n       bt.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                TextView tv = (TextView) findViewById(R.id.tv1);\n                tv.setText(\"hello android\");\n            }\n        });//内部匿名类实现按键处理\n    }\n}\n\n```\n## `2.使用自定义单击事件监听类`\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button bt = (Button) findViewById(R.id.bt1);\n        bt.setOnClickListener(new myButtonClick());//自定义事件监听类实现按钮事件处理\n    }\n    public class myButtonClick implements View.OnClickListener{\n\n       @Override\n       public void onClick(View view) {\n           TextView tv = (TextView) findViewById(R.id.tv1);\n           tv.setText(\"hello android\");\n       }\n   }\n}\n\n```\n## `3.使用lambda语法实现按钮处理`\n首先确保环境支持`lambda`语法,即JDK在1.8及以上.\n```java\n\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button bt = (Button) findViewById(R.id.bt1);\n        bt.setOnClickListener((view)->{\n            TextView tv = (TextView) findViewById(R.id.tv1);\n            tv.setText(\"hello android\");\n        });//lambda语法实现按钮处理事件\n\n    }\n}\n```\n如果在Android Studio 下报错:\n```\nError:Jack is required to support java 8 language features. Either enable Jack or remove sourceCompatibility JavaVersion.VERSION_1_8.\n```\n请在`build.gradle(Module:app)`文件加入以下代码\n```\n# 在 build.gradle 文件中加入如下代码\ndefaultConfig {\n    ...\n    jackOptions {\n        enabled true\n    }\n}\n\ncompileOptions {\n    sourceCompatibility org.gradle.api.JavaVersion.VERSION_1_8\n    targetCompatibility org.gradle.api.JavaVersion.VERSION_1_8\n}\n```\n## `4.Activity继承View.OnClickListener`\n由Activity实现OnClick(View view)方法，在OnClick(View view)方法中用switch-case对不同id代表的button进行相应的处理： \n```java\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button bt = (Button) findViewById(R.id.bt1);\n        bt.setOnClickListener((view)->{\n            TextView tv = (TextView) findViewById(R.id.tv1);\n            tv.setText(\"hello android\");\n        });//lambda语法实现按钮处理事件\n\n    }\n    public void onClick(View view) {  \n  \n        switch (view.getId()){  \n            case R.id.bt:  \n                TextView tv = (TextView) findViewById(R.id.tv1);\n\t            tv.setText(\"hello android\");  \n            break;  \n            default:  \n            break;  \n        }  \n    }  \n}\n\n```\n这个方法适合多个按钮\n\n## `5.在XML文件指定按钮的onClick属性`\n在XML文件中显示指定按钮的onClick属性，这样点击按钮时会利用反射的方式调用对应Activity中的click()方法： \n在我之前学习的Windows 10 `UWP` 的app开发中都是用的这种方法.\nUWP也是类似的在相应的XAML代码中设置click属性即可,并且Visual Studio会自动为其添加相应方法.**\\\\(▔＾▔)/ 微软大法好**\n```xml\n<Button\n        android:onClick=\"sayHelloAndroid\"\n        android:id=\"@+id/bt1\"\n        android:text=\"click\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n```\n笔者经过百度了后,发现Android Studio 有快捷键来生成click相应的方法:点击onclick的属性值,然后按Alt+Enter\n![生成方法](http://oskhhyaq3.bkt.clouddn.com/blog/170912/5jeDm9Klik.png?imageslim)\n然后就生成了相应方法,这样可以避免手动写方法时不小心拼错单词了.\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170912/547A3AcCIg.png?imageslim)\n\n我个人比较喜欢用第五种方法.界面与后台代码可以完全分开,代码量也少.不过反射最大的缺点就是影响性能和效率.","tags":["学习笔记"]},{"title":"查四六级准考证号的一种方法","url":"/2017/08/29/四六级查询准考证方法/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n利用某软件返回值,js代码查询准考证号\n<!-- more -->\n<The rest of contents | 余下全文>\n# 四六级查询准考证方法\n## 前言\n身边有好多小伙伴们有忘记四六级准考证号而且还找不回准考证的情况.\n因为以前的九九宿舍不能用了,并且网上很少提供这种查询的网站(可能是我孤陋寡闻没听过)\n所以这里分享一个贴吧大神公布的方法(该贴已被删).实际上是利用某一个软件的bug,也不知道什么时候会被封.\n## 原理\n某一软件的一个查询口语的入口,即使没有报口语,在其内部的返回值中会包含准考证号的信息,利用这点获得准考证号\n\n## 操作流程\n最好用`谷歌的chrome浏览器`,我试过edge和UC都没用.其他没测试过.\n必要条件:\n* 身份证号\n* 姓名\n\n\n下面以chrome为例:\n1. 打开chrom,转到下面网址\n```http\nhttp://app.cet.edu.cn:7066/baas/app/setuser.do?method=UserVerify\n```\n这时候会出现一堆错误,没关系,继续下一步\n![chromerror](http://oskhhyaq3.bkt.clouddn.com/blog/170829/lFCj5E5CF5.png?imageslim)\n2.按下F12打开开发者工具,点击Console切换到控制台\n![控制台](http://oskhhyaq3.bkt.clouddn.com/blog/170829/i6Gc65eAbg.png?imageslim)\n3.在下面空白光标出输入以下代码\n```javascript\n(function(d, s){ d.body.appendChild(s = d.createElement('script')).src = 'http://code.jquery.com/jquery-1.9.1.min.js'})(document);\n\n```\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170829/JBGHkmkkm0.png?imageslim)\n如果出现`Uncaught SyntaxError: Unexpected end of input`字样,应该是代码不完整或部分拼写错误.重新复制一遍就好了\n4.接下来输入另一段代码\n```javascript\nvar url = \"http://app.cet.edu.cn:7066/baas/app/setuser.do?method=UserVerify\";\nvar ks_data = {\n\"ks_xm\": \"姓名\",\n\"ks_sfz\": \"身份证号\",\n\"jb\": \"四级填1,六级填2\"\n};\nvar postdata = {\n\"action\": \"\",\n\"params\": JSON.stringify(ks_data)\n};\n$.post(url = url, data = postdata, callback = function(data) {\ndata = $.parseJSON(data)\nconsole.log(data[\"ks_bh\"])\n})\n\n```\n将上述代码的姓名,身份证等参数替换掉,回车确定\n![返回准考证号](http://oskhhyaq3.bkt.clouddn.com/blog/170829/Icg2EBD67j.png?imageslim)\n如果出现其他错误,可能你的`信息输入有误`,请核对再输一遍.如果还有错则该考生不存在(没报考).\n这个只能查最近一次的准考证.\n好了,大功告成\n点击下面:\n[四级查询路口 http://cet.neea.edu.cn/cet/](http://cet.neea.edu.cn/cet/)\n 然后就可以查分数了.\n 溜了溜了...","tags":["JavaScript"]},{"title":"Python学习笔记 (三)  简单爬虫实战","url":"/2017/08/19/Python 实战/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nPython实战 抓取网页\n<!-- more -->\n<The rest of contents | 余下全文>\n# Python 实战\n## 简单的静态文本抓取\n### request库命令安装\nwindows下进入cmd ，定位到你Python的安装路径，我的是D:\\Program Files\\Python27\\Scripts。因为以后常用，不妨加到环境变量中，以后就不用在定位到安装路径，直接调用。\n然后在cmd、PowerShell、XShell中输入以下命令\n* Windows :  pip install request\n* Linux :  sudo pip install request\n* Mac OS :  sudo pip install request  \n### 抓取目标：\n* [http://my.0ff0.net/](http://my.0ff0.net/)\n* [https://get.freevpnss.me/#vpn](https://get.freevpnss.me/#vpn)\n\n以上是两个免费的VPN网站，目标是将网站中的VPN服务器IP、用户名、密码、IPSec密钥等相关信息抓取下来以便使用。本次程序需要用到request库，如果没有安装\n### 网站分析\n#### 第一个网站\n![http://my.0ff0.net](http://oskhhyaq3.bkt.clouddn.com/blog/170726/i9GiJIBJcd.png?imageslim)\n查看其源码如下：\n![my.0ff0.nety源码](http://oskhhyaq3.bkt.clouddn.com/blog/170726/fj8DBkdhgD.png?imageslim)\n第一个网站结构和源码都比较简单，直接使用Python的正则表达式匹配其字符就行\n直接上源代码：\n```python\n# coding:utf-8\nimport requests\nimport re\nhtml = requests.get(\"http://my.0ff0.net/\")\n# html.encoding = 'utf-8'\ncontent = re.findall('<div class=\"content\">(.*?)</div>',html.text,re.S)[0]\nserverip =re.findall('<span id=\"ip\">(.*?)</span>',content,re.S)\nuser =re.findall('<span id=\"user\">(.*?)</span>',content,re.S)\npassword =re.findall('<span id=\"pw\">(.*?)\\n</span>',content,re.S)\nsecret =re.findall('<span id=\"secret\">(.*?)</span>',content,re.S)\n\n\n# print html.text\nprint \"服务器地址: %s \"%str(serverip[0])\nprint \"用户名: %s\"%str(user[0])\nprint \"密码: %s\"%str(password[0])\nprint \"IPSec密钥: %s\"%str(secret[0])\nprint \"连接方式：PPTP和Cisco IPSec(IKEv1)\"\n```\n\n运行结果：\n![运行结果](http://oskhhyaq3.bkt.clouddn.com/blog/170726/maJClL2Ha4.png?imageslim)\n\n#### 第二个网站\n![freeVPN](http://oskhhyaq3.bkt.clouddn.com/blog/170820/hkebHGd2L7.png?imageslim)\n**F12查看源码,同样用正则表达式吧需要的字符匹配出来.**\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170820/L0g8L9L5C5.png?imageslim)\n### 源码\n```python\n# coding:utf-8\nfrom encodings import gb18030\n\nimport requests\nimport re\nhtml = requests.get(\"http://jn9.org/indexcn.html\")\nhtml.encoding = 'utf-8'\n\ntarget = re.findall('<div class=\"panel-heading\">(.*?)<span class=\"label label-success\">Active</span></p>.*?</div>.*?</div>.*?</div><!-- /.col-sm-4 -->',html.text,re.S)\nfor i in range(target.__len__()):\n    adress = re.findall('<h2 class=\"panel-title\">(.*?)</h2>',target[i],re.S)\n    contend = re.findall('<p>(.*?)</p>',target[i],re.S)\n    if adress:\n        print \"地区:\",adress[0]\n    for each in contend:\n        result = re.sub('<span class=\"hidden\">(.*?)</span>', '',each)\n        print result\n    print \"\\n\\n\"\n```\n运行结果如下:\n![效果图](http://oskhhyaq3.bkt.clouddn.com/blog/170820/49jGcfChGJ.png?imageslim)\n`好了,翻个墙出去玩耍了.`","tags":["编程语言"]},{"title":"数学建模论文格式分析","url":"/2017/08/10/论文格式分析鉴赏/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n关于数学建模论文格式分析 教会你怎么写相关论文\n<!-- more -->\n<The rest of contents | 余下全文>\n# 论文格式分析鉴赏\n## 论文格式\n根据分析论文中的格式，可以总结出以下格式：\n### 摘要\n摘要的特点首先在于'短\"，要简短扼要，高度浓缩，目的是节省老师的时间、提高效率。老师阅读        摘要后，就能够确切地了解论文的主要内容和结果，决定是否需要阅读全文。摘要最好能引人入胜，使之产生看完全文的兴趣。尽量简述对问题的解决思路，最好先一句话用什么方法解决了什么类型的问题。\n* 模型的数学归类（在数学上属于什么类型）\n* 建模的思想（思路）\n* 算法思想（求解思路）\n* 建模特点（模型优点，建模思想或方法，算法特点，结果检验，灵敏度 分析，模型检验）\n* 主要结果（数值结果，结论）（回答题目所问的全部“问题”） \n### 问题分析\n根据题目给出的已知条件，结合自己的理解，分析问题的解决方法，引出解题的思路．一个一个问题有条理得分析问题．最后一段总结．\n\n### 模型假设\n首先基本假设的合理性很重要。\n* 根据题目中条件和要求作出假设 \n* 关键性假设不能缺，假设要切合题意 \n\n### 符号说明\n根据范文分析，就是将本文将会出现的数学符号通过表格清晰明了得进行说明。\n如下图\n![符号说明](http://oskhhyaq3.bkt.clouddn.com/blog/170810/EfCjfI7k8d.png?imageslim)\n\n### 模型建立与求解\n#### 基本模型： \n*  首先要有数学模型：数学公式、方案等 \n* 基本模型，要求 完整，正确，简明\n#### 简化模型:\n * 要明确说明：简化思想，依据 \n* 简化后模型，尽可能完整给出 \n模型要实用，有效，以解决问题有效为原则。 数学建模面临的、要解决的是实际问题，不追求数学上。高（级）、深（刻）、 难（度大）。\n#### 模型要求：\n* 能用初等方法解决的、就不用高级方法;\n* 能用简单方法解决的，就不用复杂方法; \n* 能用被更多人看懂、理解的方法;\n* 就不用只能少数人看懂、理解的方法\n* 鼓励创新，但要切实，不要离题搞标新立异数模创新可出现在 \n* 建模中，模型本身，简化的好方法、好策略等， \n#### 模型求解中 \n* 结果表示、分析、检验，模型检验 \n* 推广部分 \n#### 在问题分析推导过程中，需要注意的问题： \n* 分析：中肯、确切 \n* 术语：专业、内行；；  \n* 原理、依据：正确、明确, \n* 表述：简明，关键步骤要列出 \n* 忌：外行话，专业术语不明确，表述混乱，冗长。\n\n### 模型评价和推广\n#### 模型评价:\n* 优点突出（预测问题关注精度，优化问题关注性能，分类问题关注准确性，等等，根据实际问题写模型优点，一定要写到点上）\n* 缺点不回避，但是缺点要挑无关痛痒的讲，可以将假设中的不足或局限性作为缺点。\n模型推广:\n* 适用的场景、人群、范围等等（不可硬套，根据实际题目实际情况来写） \n* 推广或改进方向时，不要玩弄新数学术语（让人看得懂，复杂也要简单化，切莫把简单的描述的过于复杂）\n\n### 参考文献\n按要求的格式写\n尽量引用好的文献、书籍、资料等等\n\n### 附录\n* 程序代码（基本上是代码）\n* 详细的结果，详细的数据表格，可在此列出，但不要错，错的宁可不列。\n* 主要结果数据应在正文中列出，不怕重复。 ","tags":["论文"]},{"title":"Python学习笔记 (二)  第三方库安装","url":"/2017/07/22/第三方库安装/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nPython的第三方库的安装\n<!-- more -->\n<The rest of contents | 余下全文>\n## 第三方库安装\n### 命令安装\nwindows下进入cmd ，定位到你Python的安装路径，我的是D:\\Program Files\\Python27\\Scripts。因为以后常用，不妨加到环境变量中，以后就不用在定位到安装路径，直接调用。\n然后在cmd、PowerShell、XShell中输入以下命令\n* Windows :  pip install xxx\n* Linux :  sudo pip install xxx\n* Mac OS :  sudo pip install xxx   \n\n     \n`少用easy_install 因为只能安装不能卸载`\n### 自定义安装\n 当出现问题或者不想用命令安装时  请戳>>[http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/)\n 这个网站有Python所有的第三方库文件。将下载好的文件原后缀.whl改为.zip,并解压到python安装目录的Lib文件夹下。","tags":["编程语言"]},{"title":"Python学习笔记 (一)  初识Python","url":"/2017/07/22/初识Python/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n认识Python及搭建开发环境\n<!-- more -->\n<The rest of contents | 余下全文>\n#  初识Python\n##  Python\n>Python[1]  （英国发音：/ˈpaɪθən/ 美国发音：/ˈpaɪθɑːn/）, 是一种面向对象的解释型计算机程序设计语言，由荷兰人Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。\nPython是纯粹的自由软件， 源代码和解释器CPython遵循 GPL(GNU General Public License)协议[2]  。Python语法简洁清晰，特色之一是强制用空白符(white space)作为语句缩进。\nPython具有丰富和强大的库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中[3]  有特别要求的部分，用更合适的语言改写，比如3D游戏中的图形渲染模块，性能要求特别高，就可以用C/C++重写，而后封装为Python可以调用的扩展类库。需要注意的是在您使用扩展类库时可能需要考虑平台问题，某些可能不提供跨平台的实现。--百度百科\n\n***个人认为Python是一款非常适合初学者的语言，同时有面向过程和对象的特性，语法简单非常接近自然语言，功能强大***\n## 发展历程\n>自从20世纪90年代初Python语言诞生至今，它已被逐渐广泛应用于系统管理任务的处理和Web编程。\nPython的创始人为Guido van Rossum。1989年圣诞节期间，在阿姆斯特丹，Guido为了打发圣诞节的无趣，决心开发一个新的脚本解释程序，做为ABC 语言的一种继承。之所以选中Python（大蟒蛇的意思）作为该编程语言的名字，是因为他是一个叫Monty Python的喜剧团体的爱好者。\nABC是由Guido参加设计的一种教学语言。就Guido本人看来，ABC 这种语言非常优美和强大，是专门为非专业程序员设计的。但是ABC语言并没有成功，究其原因，Guido 认为是其非开放造成的。Guido 决心在Python 中避免这一错误。同时，他还想实现在ABC 中闪现过但未曾实现的东西。\n就这样，Python在Guido手中诞生了。可以说，Python是从ABC发展起来，主要受到了Modula-3（另一种相当优美且强大的语言，为小型团体所设计的）的影响。并且结合了Unix shell和C的习惯。\nPython[4]  已经成为最受欢迎的程序设计语言之一。2011年1月，它被TIOBE编程语言排行榜评为2010年度语言。自从2004年以后，python的使用率呈线性增长[5]  。\n由于Python语言的简洁性、易读性以及可扩展性，在国外用Python做科学计算的研究机构日益增多，一些知名大学已经采用Python来教授程序设计课程。例如卡耐基梅隆大学的编程基础、麻省理工学院的计算机科学及编程导论就使用Python语言讲授。众多开源的科学计算软件包都提供了Python的调用接口，例如著名的计算机视觉库OpenCV、三维可视化库VTK、医学图像处理库ITK。而Python专用的科学计算扩展库就更多了，例如如下3个十分经典的科学计算扩展库：NumPy、SciPy和matplotlib，它们分别为Python提供了快速数组处理、数值运算以及绘图功能。因此Python语言及其众多的扩展库所构成的开发环境十分适合工程技术、科研人员处理实验数据、制作图表，甚至开发科学计算应用程序。\n说起科学计算，首先会被提到的可能是MATLAB。然而除了MATLAB的一些专业性很强的工具箱还无法替代之外，MATLAB的大部分常用功能都可以在Python世界中找到相应的扩展库。和MATLAB相比，用Python做科学计算有如下优点：\n● 首先，MATLAB是一款商用软件，并且价格不菲。而Python完全免费，众多开源的科学计算库都提供了Python的调用接口。用户可以在任何计算机上免费安装Python及其绝大多数扩展库。\n● 其次，与MATLAB相比，Python是一门更易学、更严谨的程序设计语言。它能让用户编写出更易读、易维护的代码。\n● 最后，MATLAB主要专注于工程和科学计算。然而即使在计算领域，也经常会遇到文件管理、界面设计、网络通信等各种需求。而Python有着丰富的扩展库，可以轻易完成各种高级任务，开发者可以用Python实现完整应用程序所需的各种功能。\n\n## 风格\n>Python在设计上坚持了清晰划一的风格，这使得Python成为一门易读、易维护，并且被大量用户所欢迎的、用途广泛的语言。\n设计者开发时总的指导思想是，对于一个特定的问题，只要有一种最好的方法来解决就好了。这在由Tim Peters写的Python格言（称为The Zen of Python）里面表述为：There should be one-- and preferably only one --obvious way to do it. 这正好和Perl语言（另一种功能类似的高级动态语言）的中心思想TMTOWTDI（There's More Than One Way To Do It）完全相反。\nPython的作者有意的设计限制性很强的语法，使得不好的编程习惯（例如if语句的下一行不向右缩进）都不能通过编译。其中很重要的一项就是Python的缩进规则。\n一个和其他大多数语言（如C）的区别就是，一个模块的界限，完全是由每行的首字符在这一行的位置来决定的（而C语言是用一对花括号{}来明确的定出模块的边界的，与字符的位置毫无关系）。这一点曾经引起过争议。因为自从C这类的语言诞生后，语言的语法含义与字符的排列方式分离开来，曾经被认为是一种程序语言的进步。不过不可否认的是，通过强制程序员们缩进（包括if，for和函数定义等所有需要使用模块的地方），Python确实使得程序更加清晰和美观。\n# 搭建环境\n## 下载Python\n官网下载[Python](https://www.python.org/),建议下载Python 2.X 版的。目前网上大部分教程为2.X版。3.X版改进很大。这里是一些关于2和3版本的区别和指导，请自己斟酌\n[Python3.x和Python2.x的区别](http://www.cnblogs.com/codingmylife/archive/2010/06/06/1752807.html)\n[应该学习最新版本的 Python 3 还是旧版本的 Python 2？](https://www.zhihu.com/question/24549965)![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170722/l6aFIFLfC3.png?imageslim)\n## 配置环境变量\n我的电脑右键属性-高级系统变量-环境变量-向Path 添加Python的安装路径\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170722/Ebeb0LC1iE.png?imageslim)\n## 下载IDE\n点击这里有推荐  [提供给开发者 10 款最好的 Python IDE](http://www.oschina.net/news/57468/best-python-ide-for-developers)\n另外VIsual Studio 也可以。我自己使用破解版的`JetBrains PyCharm`[下载](https://www.jetbrains.com/pycharm/) 。\n![PyCharm](http://oskhhyaq3.bkt.clouddn.com/blog/170722/b4mFhHgAFj.png?imageslim)\n然后就愉快的玩耍了","tags":["编程语言"]},{"title":"UWP学习笔记 (三)   XAML界面原理和语法","url":"/2017/07/10/什么是XAML/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n学习XAML在UWP 中的原理及语法\n<!-- more -->\n<The rest of contents | 余下全文>\n## 什么是XAML\n>XAML是EXtensible Application Markup Language的英文缩写，相应的中文名称为可扩展应用程序标记语言，它是微软公司为构建应用程序用户界面而创建的一种新的描述性语言。XAML提供了一种便于扩展和定位的语法来定义和程序逻辑分离的用户界面，而这种实现方式和ASP.NET中的\"代码后置\"模型非常类似。XAML是一种解析性的语言，尽管它也可以被编译。它的优点是简化编程式上的用户创建过程，应用时要添加代码和配置等。 --百度百科\n\n### 优点\n&#160;&#160;&#160;&#160;XAML简化了.Net Framework 3.0编程模式上的用户界面创建过程，使用XAML开发人员可以对WPF程序的所有用户界面元素(例如文本、按钮、图像和列表框等)进行详细的定置，同时还可以对整个界面进行合理化的布局，这与使用HTML非常相似。但是由于XAML是基于XML的，所以它本身就是一个组织良好的XML文档，而且相对于HTML，它的语法更严谨、更明确。预计以后大部分的XAML都可由相应的软件自动生成，就如同我们现在制作一个静态页面时，几乎不用编写任何HTML代码就可以直接通过Dreamweaver软件生成一个美观的页面。但是最初通过手动编写XAML代码将是一次绝佳的学习体验，虽然实现的过程繁杂了些，但是将加深您对XAML语法和各个元素的理解。\n大多数的WPF程序可能同时包含程序代码和 XAML。我们可以使用XAML定义应用程序的初始界面，而后才编写相应的功能实现代码。我们可以将逻辑代码直接嵌入到一个XAML文件中，也可以将它保留在一个单独的文件中。实际上，能够用XAML实现的所有功能我们都可以使用程序代码来完成。因此，我们根本无需使用任何的XAML就可以创建一个完好的WPF程序。一般来说，程序代码的优势在于流程处理和逻辑判断，而不是界面的构建上。而XAML则是集中关注于界面的编程，我们可以将它和其它的.NET语言配合使用，从而构建出一个功能完善、界面美观的WPF程序。XAML是一种纯正的、用来描述用户界面构成元件和编排方式的标记语言。尽管有部分的XAML语法具备程序设计语言的特性(例如XAML中的Trigger和TRansform)，但是XAML并不是一种用于程序设计的语言，它的功能也不是为了执行应用程序逻辑。\n&#160;&#160;&#160;&#160;微软推荐XAML被编译成BAML(Binary Application Markup Language-二进制语言程序标记语言)。XAML和BAML都可以被WPF解析，并且将以一种和HTML相似的方式进行界面的呈现。但是和HTML不同的是，XAML是强类型化的。也就是说，HTML会忽略那些它不能识别的元素和属性，而XAML必须在识别所有的元素和属性的情况下，才对页面进行呈现。尽管在XAML中各个属性都是以一个个的字符串(例如Background)表示的，但是这些字符串实际上代表的是WPF中的对象，只有被WPF识别的对象才可以作为元素的属性，所以我们说XAML是强类型化的。\n### 新功能\n微软Build 2013发布了一些已经被添加到Windows 8.1中的XAML新功能。[1]  \n* Hub控件\n* 命令栏\n* 弹出（Flyout）控件\n* 日期/时间选择控件\n* 取消StandardStyles.xaml\n### 与HTML的区别\n&#160;&#160;&#160;&#160;还有一点是我们反复强调的，XAML并不是HTML。尽管XAML在元素的声明、程序样式的设置和指定事件处理程序上都和HTML非常类似，但是XAML是基于XML的，它是WPF的外在表现形式。而HTML只是一种标记语言，仅仅是用来为浏览器呈现页面内容。XAML除了用来呈现信息和请求用户输入等基本的功能外，它还包含了一些高级的特性，例如它提供了对动画和3D众多方面的支持。\nXAML是可扩展的，正如它的名字指明的那样。开发人员可以创建自定义的控件、元素和函数来扩展XAML。而且由于XAML各元素在本质上就是WPF类的映射，所以开发人员可以很轻松地使用面向对象的技术对XAML元素进行扩展。也就是说我们可以开发一些自定义控件和组合元素，并将它公开给用户界面设计人员和其它的开发人员使用。\n\n## XAML代码在UWP中的角色\n* Page是UWP的用户界面主体。传统桌面程序是由一个个窗口组成的，而UWP是由一个Page（页面）组成的\n*  Page是一个partial类\n*  我们的任务是扩展Page这个类\n\t* 微软预制的Page为一个空的界面，没有内容\n\t* 我们只能扩展它\n*  XAML代码是界面部分，用来实例化.NET对象的标记语言。它可以非常简单的创建对象。\n如下图，这段XAML代码创建了一个Button 对象\n![XAML代码](http://oskhhyaq3.bkt.clouddn.com/blog/170711/L1H43BAcC0.jpg?imageslim)\n同样的用C#实现会怎么样呢？\n![C#代码](http://oskhhyaq3.bkt.clouddn.com/blog/170711/Cabge4dJHj.jpg?imageslim)\n&#160;&#160;&#160;&#160;&#160;XAML中的Margin是直接等于一个字符串，而C#中是需要给Margin赋值一个Thickness对象的。这归功于XAML的类型转换器。XAML在编译的时候，XAML语法分析器将字符串转换为对应的对象或枚举值，这样的话，我们可以直接用一个非常简单的值来代替冗长的类型名和枚举值来提高效率。\n## XAML语法\n### Content Property （内容属性）\n每个标签都有自己的默认的内容属性。比如`<Grid/>`的默认属性是`<Grid.Children><Grid.Children/>`,`<Button>`的默认属性是`<Button.Content>`.通常内容属性可省略。\n### self-closing \nXAML标签与其他标签类似有两种开闭形式\n*  `<xxx><xxx/>`\n* `<xxx/>`\n### Attribute 与简单的property\n可以直接在标签内定义该控件的一些简单属性，比如\n```xml\n<Button Name=\"button\" Height=\"200\" Width=\"200\"/>\n```\n### 复杂的property与property标签\n标签里的属性对象很复杂的时候，编译器无法将字符转化成对象是，就需要使用属性标签。\n比如说，当我要设置背景颜色时，如果时简单的颜色可以直接这样\n```xml\n<Grid Background=\"red\">\n</Grid>\n```\n当然，我们肯定不能满足这种单一色调的背景，我想要一个渐变的漂亮的背景怎么做呢？\n```xml\n<Grid>\n        <Grid.Background>\n\t        <!--LinearGradientBrush为线性笔刷-->\n            <LinearGradientBrush EndPoint=\"0.5,1\" StartPoint=\"0.5,0\">\n\t\t\t\t<!--从#FFAC6CC开始 偏移量为0，#FF2D7099 结束偏移量为1-->            \n                <GradientStop Color=\"#FFACD6CC\" Offset=\"0\"/>\n                <GradientStop Color=\"#FF2D7099\" Offset=\"1\"/>\n            </LinearGradientBrush>\n        </Grid.Background>\n </Grid>\n\n```\n\n### 特殊属性（UWP，WPF特有）\n* Dependency Property 依赖属性\n依赖属性就是自己自己没有值，通过Binding从数据源获得值，就是依赖在别人身上，拥有依赖属性的对象称为依赖对象。\n几种应用依赖属性的场景： \n 1. 希望可在样式中设置属性。 \n2. 希望属性支持数据绑定。 \n3. 希望可使用动态资源引用设置属性。 \n4. 希望从元素树中的父元素自动继承属性值。 \n5. 希望属性可进行动画处理。 \n6. 希望属性系统在属性系统、环境或用户执行的操作或者读取并使用样式更改了属性以前的值时报告。 \n7. 希望使用已建立的、WPF 进程也使用的元数据约定，例如报告更改属性值时是否要求布局系统重新编写元素的可视化对象。 \n依赖对象创建时并不包含存储数据空间。WPF中必须使用依赖对象作为依赖属性的宿主。\n ```xml\n \n <TextBox x:Name=\"textBox1\" Margin=\"10\"  Text=\"{Binding Path=Title}\"/>\n ```\n* Attached Property 附加属性 。附加属性为本不应该是该控件的属性而在该控件下设置的属性。\n比如\n```xml\n<Grid>\n\t<!--声明该Grid有三行-->\n\t<Grid.RowDefinitions>\n            <RowDefinition Height=\"auto\"/>\n            <RowDefinition Height=\"auto\"/>\n            <RowDefinition Height=\"auto\"/>\n       </Grid.RowDefinitions>\n    <!--这里的Grid.row本来是Grid的属性，却被当做是Button的属性。Grid.Row为Button的附加属性-->  \n\t<Button Grid.Row=\"2\"/>\n</Grid>\n```","tags":["UWP"]},{"title":"UWP学习笔记 (二)   UWP开发环境及项目工程解析","url":"/2017/07/09/开发环境及项目工程解析/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n介绍开发环境及UWP的组成部分\n<!-- more -->\n<The rest of contents | 余下全文>\n# 开发环境及项目工程解析\n工欲善其事，必先利其器。本章将介绍如何搭建Windows 10通用应用开发的环境以\n及开发第一个Windows 10通用应用程序，并解析其工程结构和代码以及如何适配不同平\n台的特殊代码。\n## 搭建开发环境\n### 开发环境的要求\n进行Windows 10的开发，计算机需要达到以下要求\n* 1.操作系统Windows 10(64位专业版)。\n* 2.系统盘需要至少8G的剩余硬盘空间。\n* 3.内存达到4GB以上。\n* 4.Windows10的手机模拟器基于Hyper-V,需要CPU支持二级地址转换技术。\n\n注意部分计算机会默认关闭主板BIOS的虚拟化技术，这时需要进入主板BIOS设置\n页面开启虚拟化技术，然后再启动或者关闭Windows功能界面启动Hyper-V服务。\n\n###开发工具的安装\n\nWindows10 SDK已集成在Visual Studio上o 2015最新的版本中。开发工具可以直接到敝\n软的Windows开发者网站进行下载([https //dev.windows.com](https //dev.windows.com))，由于开发工具的更新速\n度较快，请以官方最新版本为准。安装完成后，里面包含了程序的SDK.运行模拟器和编程\n工具。Windows 10 Developer Tools包含的工具集合详细信息如下\n\n* 1.Visual Stuio是Winoows 10的集成开发环境(IDE)，其中包括了C#和XAML.代码编辑\n功能、简单界面的布局与设计功能、编译程序、连接模拟器、部署程序，以及调试程序等功能。\n* 2.Emulator是Winows 10的模拟器，开发者可以把应用程序部署到各种分辨率的模拟器上来检查程序运行效果。如果用户有Windows 10手机，可以直接使用手机来调试和运行自己编的程序。\n## 创建Windows 10 通用应用\n打开Visual Studio 2015/2017。本人用的是Visual Studio 2017。新建一个C#通用项目\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170710/cAjddJLAIJ.png?imageslim)\n![新建UWP项目](http://oskhhyaq3.bkt.clouddn.com/blog/170710/0LJL24D0fm.png?imageslim)\n编辑MainPage.xaml文件，添加以下代码\n```xml\n <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock HorizontalAlignment=\"Center\" Margin=\"125,105,0,0\" TextWrapping=\"Wrap\" Text=\"Hello World\" VerticalAlignment=\"Center\" FontSize=\"72\"/>\n    </Grid>\n```\n如图：\n![hello world](http://oskhhyaq3.bkt.clouddn.com/blog/170710/G7JCl403Eg.png?imageslim)\n运行结果：\n![结果](http://oskhhyaq3.bkt.clouddn.com/blog/170710/KCl6BB6mAG.png?imageslim)\n## 解析Hello World 应用\nHello World 项目工程中里面包含了MainPage.xaml文件、MainPage.xaml.cs文件、App.xaml文件、App.xaml.cs文件、Package.appxmanifest文件、AssemblyInfo.cs文件和一些图片文件。\n### MainPage.xaml 文件\n```xml\n<Page\n    x:Class=\"HelloWorld.MainPage\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:HelloWorld\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"d\">\n\n    <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock HorizontalAlignment=\"Center\" Margin=\"125,105,0,0\" TextWrapping=\"Wrap\" Text=\"Hello World\" VerticalAlignment=\"Center\" FontSize=\"72\"/>\n\n\n    </Grid>\n</Page>\n\n```\n&#160;&#160;&#160;&#160;Page元素是一个程序页面的根元素，表示当前的XAML代码是一个页面，当前页面的其他所有UI元素都必须在Page元素下面。在当前的页面里面有两个控件：Grid控件、TextBlock法控件。其中，Grid控件是布局容器控件，所以在可视化视图上并没有看到Grid控件的显示。Text131ock控件是一个文本框控件，用于显示文本的内容，在可视化视图上看到的。“TextBlock”就是TextBlock控件。在上面的页面代码中可以看到TextBlock控件里面还有很多属性，这些属性用于定义控件的各种特性的设置。例如，\"x Name。属性定义了\n控件的名称，在后台代码里就可以通过名称来访问控件。Text。属性定义了TextBlock控\n件文本显示的内容，等等。\n\n### MainPage.xmal.cs文件\n```cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.InteropServices.WindowsRuntime;\nusing Windows.Foundation;\nusing Windows.Foundation.Collections;\nusing Windows.UI.Xaml;\nusing Windows.UI.Xaml.Controls;\nusing Windows.UI.Xaml.Controls.Primitives;\nusing Windows.UI.Xaml.Data;\nusing Windows.UI.Xaml.Input;\nusing Windows.UI.Xaml.Media;\nusing Windows.UI.Xaml.Navigation;\n\n// https://go.microsoft.com/fwlink/?LinkId=402352&clcid=0x804 上介绍了“空白页”项模板\n\nnamespace HelloWorld\n{\n    /// <summary>\n    /// 可用于自身或导航至 Frame 内部的空白页。\n    /// </summary>\n    public sealed partial class MainPage : Page\n    {\n        public MainPage()\n        {\n            this.InitializeComponent();\n        }\n    }\n}\n\n```\n&#160;&#160;&#160;&#160;MainPage.xmal.cs文件就是MainPage.xmal文件对应的后台代码的处理，在MainPage.xmal.cs文件会完成程序页面的控件的初始化工作和处理控件的触发事件。\n###  App.xaml 文件\n```xml\n<Application\n    x:Class=\"HelloWorld.App\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:HelloWorld\"\n    RequestedTheme=\"Light\">\n\n</Application>\n```\n&#160;&#160;&#160;&#160;App.xaml文件是应用程序的入口XAML文件，一个应用程序只有一个该文件，并且\n它还会有一个对应的App.xaml.cs文件。App.xaml文件的根节点是Appplication元素，它\n里面的属性定义和空间定义与上面的Mainpage.xaml页面是一样的，不一样的地方是在\nApp.xam]文件中定义的元素是对整个应用程序是公用的，例如你在App.xaml文件中，添\n加了〈Application，Resources〉</Application.Resources>元素来定义一些资源文件或者样式，这些资源在整个应用程序的所有页面都可以引用，而在Page的页画所定义的资源或者控件就只能否在当前的页面使用。\n###  App.xaml.cs\n```cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.InteropServices.WindowsRuntime;\nusing Windows.ApplicationModel;\nusing Windows.ApplicationModel.Activation;\nusing Windows.Foundation;\nusing Windows.Foundation.Collections;\nusing Windows.UI.Xaml;\nusing Windows.UI.Xaml.Controls;\nusing Windows.UI.Xaml.Controls.Primitives;\nusing Windows.UI.Xaml.Data;\nusing Windows.UI.Xaml.Input;\nusing Windows.UI.Xaml.Media;\nusing Windows.UI.Xaml.Navigation;\n\nnamespace HelloWorld\n{\n    /// <summary>\n    /// 提供特定于应用程序的行为，以补充默认的应用程序类。\n    /// </summary>\n    sealed partial class App : Application\n    {\n        /// <summary>\n        /// 初始化单一实例应用程序对象。这是执行的创作代码的第一行，\n        /// 已执行，逻辑上等同于 main() 或 WinMain()。\n        /// </summary>\n        public App()\n        {\n            this.InitializeComponent();\n            this.Suspending += OnSuspending;\n        }\n\n        /// <summary>\n        /// 在应用程序由最终用户正常启动时进行调用。\n        /// 将在启动应用程序以打开特定文件等情况下使用。\n        /// </summary>\n        /// <param name=\"e\">有关启动请求和过程的详细信息。</param>\n        protected override void OnLaunched(LaunchActivatedEventArgs e)\n        {\n            Frame rootFrame = Window.Current.Content as Frame;\n\n            // 不要在窗口已包含内容时重复应用程序初始化，\n            // 只需确保窗口处于活动状态\n            if (rootFrame == null)\n            {\n                // 创建要充当导航上下文的框架，并导航到第一页\n                rootFrame = new Frame();\n\n                rootFrame.NavigationFailed += OnNavigationFailed;\n\n                if (e.PreviousExecutionState == ApplicationExecutionState.Terminated)\n                {\n                    //TODO: 从之前挂起的应用程序加载状态\n                }\n\n                // 将框架放在当前窗口中\n                Window.Current.Content = rootFrame;\n            }\n\n            if (e.PrelaunchActivated == false)\n            {\n                if (rootFrame.Content == null)\n                {\n                    // 当导航堆栈尚未还原时，导航到第一页，\n                    // 并通过将所需信息作为导航参数传入来配置\n                    // 参数\n                    rootFrame.Navigate(typeof(MainPage), e.Arguments);\n                }\n                // 确保当前窗口处于活动状态\n                Window.Current.Activate();\n            }\n        }\n\n        /// <summary>\n        /// 导航到特定页失败时调用\n        /// </summary>\n        ///<param name=\"sender\">导航失败的框架</param>\n        ///<param name=\"e\">有关导航失败的详细信息</param>\n        void OnNavigationFailed(object sender, NavigationFailedEventArgs e)\n        {\n            throw new Exception(\"Failed to load Page \" + e.SourcePageType.FullName);\n        }\n\n        /// <summary>\n        /// 在将要挂起应用程序执行时调用。  在不知道应用程序\n        /// 无需知道应用程序会被终止还是会恢复，\n        /// 并让内存内容保持不变。\n        /// </summary>\n        /// <param name=\"sender\">挂起的请求的源。</param>\n        /// <param name=\"e\">有关挂起请求的详细信息。</param>\n        private void OnSuspending(object sender, SuspendingEventArgs e)\n        {\n            var deferral = e.SuspendingOperation.GetDeferral();\n            //TODO: 保存应用程序状态并停止任何后台活动\n            deferral.Complete();\n        }\n    }\n}\n```\n&#160;&#160;&#160;&#160;App.xaml.cs 文件是一个控制整个应用程序的全局文件，整个应用程序的生命周期都在该文件中定义和处理。应用程序在整个生命周期会有三个状态：Running（运行），NotRunning（未运行）和 Suspended（挂起）\n![应用程序生命周期](http://oskhhyaq3.bkt.clouddn.com/blog/170710/DmKlm3EJ1b.png?imageslim)\n### Package.appxmanifest文件\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<Package\n  xmlns=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10\"\n  xmlns:mp=\"http://schemas.microsoft.com/appx/2014/phone/manifest\"\n  xmlns:uap=\"http://schemas.microsoft.com/appx/manifest/uap/windows10\"\n  IgnorableNamespaces=\"uap mp\">\n\n  <Identity\n    Name=\"f85505e4-25a4-4f06-b489-dfc4750ab693\"\n    Publisher=\"CN=Lovemefan\"\n    Version=\"1.0.0.0\" />\n\n  <mp:PhoneIdentity PhoneProductId=\"f85505e4-25a4-4f06-b489-dfc4750ab693\" PhonePublisherId=\"00000000-0000-0000-0000-000000000000\"/>\n\n  <Properties>\n    <DisplayName>HelloWorld</DisplayName>\n    <PublisherDisplayName>Lovemefan</PublisherDisplayName>\n    <Logo>Assets\\StoreLogo.png</Logo>\n  </Properties>\n\n  <Dependencies>\n    <TargetDeviceFamily Name=\"Windows.Universal\" MinVersion=\"10.0.0.0\" MaxVersionTested=\"10.0.0.0\" />\n  </Dependencies>\n\n  <Resources>\n    <Resource Language=\"x-generate\"/>\n  </Resources>\n\n  <Applications>\n    <Application Id=\"App\"\n      Executable=\"$targetnametoken$.exe\"\n      EntryPoint=\"HelloWorld.App\">\n      <uap:VisualElements\n        DisplayName=\"HelloWorld\"\n        Square150x150Logo=\"Assets\\Square150x150Logo.png\"\n        Square44x44Logo=\"Assets\\Square44x44Logo.png\"\n        Description=\"HelloWorld\"\n        BackgroundColor=\"transparent\">\n        <uap:DefaultTile Wide310x150Logo=\"Assets\\Wide310x150Logo.png\"/>\n        <uap:SplashScreen Image=\"Assets\\SplashScreen.png\" />\n      </uap:VisualElements>\n    </Application>\n  </Applications>\n\n  <Capabilities>\n    <Capability Name=\"internetClient\" />\n  </Capabilities>\n</Package>\n```\n&#160;&#160;&#160;&#160;Package.appxmanifest文件是Windows 10应用程序的清单文件，声明应用的标识、应\n用的功能以及用来进行部署和更新的信息。可以在清单文件对当前的应用程序进行配置，\n例如添加磁帖图像和初始屏幕、指示应用支持的方向以及定义应用的功能种类、Package \n元素是整个清单的根节点；Identity元素表示应用程序版本发布者名称等信息mp: \nPhoneldentity元素表示应用程序相关的唯一标识符信息Properties元素包含了应用程序\n的名称、发布者名称等信息的设置；Prerequisites元素则是用于设置应用程序所支持的系\n统版本号；Resources元素表示应用程序所使用资源信息，例如语言资源Applications元\n素里面则包含了与应用程序相关的logo设置、闪屏图片设置等可视化的设置信息\nCapabilities元素表示当前应用程序所使用的一些手机特定功能，例如internetclient表示\n使用网络的功能。\n\n&#160;&#160;&#160;&#160;Page.appxmanifest文件可以支持在可视化图形中进行设置，可以双击解决方案中\n的package.appxmanifest文件来打开此文件的可视化编辑视图。我们可以直接在可视化界\n面上设置程序的logo、磁贴、功能权限等。在后续的应用程序开发里面有些功能会需要在\nPackage.appxmanifest清单文件上进行相关的配置，到时候再进行详细的讲解。\n\n\n\n## 不同平台设备的适配\n\n&#160;&#160;&#160;&#160;Windows 10通用应用程序针对特定的平台还会有一个子API的集合，当我们要使用\n到某个平台的特定API的时候(例如手机相机硬件按钮触发事件)，这时候就需要调用特定\n平台的API.因为Winclows 10应用程序是一个安装包，可以部署到所有的Windows 10系\n统平台，所以这里就涉及一个八PI适配的问题，对特定平台的API进行特殊处理。除了特\n定平台的API,还有一个适配的工作就是界面适配，Windows 10也提供了一系列的API来\n给我们做界面的适配工作。\n\n###特定平台的API调用\n\n&#160;&#160;&#160;&#160;目前在Winclows 10里面有Windows Mobile Extension SDK和田indows Desktop \nExtension SDK两个扩展的SDK分别表示手机版本和桌面版本的扩展SDK(在后面\n章节里面若用到特定平台的API,都会进行区分标识)。这两个SDK都是直接内置在\nWindows 10的开发SDK里面的，但是默认情况下不会给项目工程添加上，需要使用时可以\n在项目工程里面引用，路径为Project->Add Reference->-Windows Universal->Extensions. \n在使用特定平台的API的时候，必须判断当前的环境是否支持(不支持的平台调用将会引\n发异常)。判断的方法为Windows.Foundation.Metadata.ApiInformation.IsTypepresent \n(String type Name)，type Name表示带完整的命名空间的API的名称，返回true表示支持，\n返回false表示不支持。\n\n\n##界面适配\n&#160;&#160;&#160;&#160;Windows 10系统支持多种硬件平台和分辨率，Windows 10系统底层对界面的适配色\n昼非常强大的，同样的控件在不同的硬件平台上显示也可能会有差异，这种适配就是由\nWindows 10系统自己来完成适配，来匹配不同的硬件和分辨率的显示效果。虽然\nWindpws 10底层完成了各种控件的适配，但是很多时候还是需要在程序里来实现适配。在 \n开发通用程序的时候，要充分地考虑各种不同分辨率下的显示效果，可以通过可视化设计界\n面和各种分辨率的模拟器来进行测试。适配界面有几种常用的编程技巧\n* 使用相对的布局控件来进行排列，如Grid.Relativepanel等;\n* 使用相对的属性来设置控件在容器的位置，如orizontalAlignment.VerticalAlignment属性;\n* 设置长度宽度的最大值最小值限制;\n* 根据设备实际分辨率来设置长度宽度或者位置。\n\n\n\n","tags":["UWP"]},{"title":"UWP学习笔记 (一) 初识UWP","url":"/2017/07/08/什么是UWP/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n认识UWP及开发前的一些准备\n<!-- more -->\n<The rest of contents | 余下全文>\n## 什么是UWP\n>UWP即Windows 10 中的Universal Windows Platform简称。即Windows通用应用平台，在Win 10 Mobile/Surface(Windows平板电脑）/PC/Xbox/HoloLens等平台上运行，uwp不同于传统pc上的exe应用也跟只适用于手机端的app有本质区别。它并不是为某一个终端而设计，而是可以在所有windows10设备上运行。\n微软在MWC 2015上首次展示了Win10统一平台战略的“代表作”：Win10通用应用（Windows10 Universal App）平台。在Win10中，所有设备将会运行在一个统一的Windows10系统核心之上。这样的设计使得一款应用可以在所有Win10设备上运行，今后Win10手机、平板电脑、笔记本电脑、PC、Xbox，甚至是3D全息眼镜HoloLens、巨屏触控Surface Hub和物联网设备例如Raspberry Pi 2等都不再有界限。新的通用平台允许新类型的Windows10通用应用真正实现一次编写、一套业务逻辑和统一的用户界面。应用在统一的Win10商店中将只会有一个安装包，而它将适用于所有Win10设备。[1]  在 Windows 10 Insider Preview 中的 Universal Windows Platform (UWP)借助 Windows 10 UWP 将在 Windows 应用中更上一层楼。UWP 会根据不同的设备类型使用相应的自适应 UI 控件，并使用运行 Windows 10 Insider Preview 的所有设备上必须具有的通用 API 集。简单的说，uwp就是通用应用的意思可以在电脑端，手机端，或其他设备通用。不用分别为不同的平台设计不同的软件。即一个软件就可以通吃。这是微软为win10系统定制的趋势。微软声称不管是开发者，还是使用者，都省事。   --百度百科\n\n首先来欣赏一下国内一些比较用心的UWP\n**网易云音乐**\n![网易云音乐](http://oskhhyaq3.bkt.clouddn.com/blog/170708/HJG2J760dA.png?imageslim)\n\n**IT之家**\n![IT之家](http://oskhhyaq3.bkt.clouddn.com/blog/170708/A65Aa9ECm6.png?imageslim)\n### 如何获取UWP\n* 1.从Window 应用商店获取。打开应用商店，搜索并选择下载。\n* 2.[离线部署](https://www.windows10.pro/how-to-install-uwp-offline-packages)\n## 开发准备\n* 开发环境：Windows 10 +Visual Studio 2015/2017    这里说明必须是**Windows 10 **，其他不行。VS 2015及以上才支持UWP开发，所以只能用VS 2015或2017。我目前的环境是 Win10 创意者 + VS 2017。\n* 开发者模式。前往 设置-更新与安全-针对开发者-开发者模式\n* 技术储备 C#/C++/VB 后期我们将使用C#进行开发程序的逻辑部分 [C#微软官方教程（有中文字幕）](http://bit.do/csharp-fundamentals)\n* XAML(EXtensible Application Markup Language)。XAML是一种类似HTML的标记语言。用来设计UI部分后面会着重学习XAML语言。如果是有HTML基础的同学会很容易上手。\n## 总结\n我对windows Phone有一种特有的情怀，从之前的Windows Phone 7 开始，我就喜欢Windows Phone上了其流畅顺滑的操作。到后来的Windows 10 mobile 。由于其软件生态太差，无法满足生活需求，我才不得不转向Android阵营。以前Android的卡慢是我无法忍受的，但随着Android 6.0/7.0，即将发布的Android 8.0，Android慢慢优化的系统也能适应大部分人的需求。Android，iOS是大势所趋，我为什么还要选择UWP这种有些人听都没听过的平台呢？\n* 首先，我看重的是UWP的优势，一次编译，能在所有Win 10 设备运行，包括电脑、平板、手机(Win10 手机)、XBox、HoloLens、surface Hub、loT(物联网)。微软费尽心思推广Win10，就是为了增加UWP的运行环境。现在及未来Win10的装机量不容小视。而且UWP小巧轻便，前途无可限量。\n* 其次，UWP有着自己的类似Google Play和Apple Store的应用商店，保证其安全性。\n* 然后，我想尽自己一份微薄力量来完善Windows 生态，主要还是Windows phone的生态。\n## 学习资料\n* UWP微软官方学习课程 [官方MVA]]() [bilibili搬运](http://www.bilibili.com/video/av7997007/)\nMicrosoft Virtual Academy (MVA)   [【链接】](https://mva.microsoft.com/)是微软官方的一个免费的视频教学课堂。里面有大量的学习资源(有中文字幕)，强烈推荐。\n* 深出浅入UWP （中文课程）[【bilibili】](http://www.bilibili.com/video/av3610677)","tags":["UWP"]},{"title":"PowerShell篇 (一) 初识PowerShell","url":"/2017/07/05/PowerShell篇  (一)初识PowerShell/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n什么是PowerShell\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 初识PowerShell\n`作者：lovemefan` `以下资料收集于IT之家和知乎`\n## PowerShell的邂逅\n&#160;&#160;&#160;&#160;在我搭建我的博客的时候，cmd命令肯定是少不了的。除了cmd我们还可以选择Git Bash和PowerShell。\nGit Bash是Git自带的一个命令行工具，用来上传，克隆等一些GitHub的操作。我之前也只知道Power Shell也是命令行，用它部署过离线的[UWP](http://baike.baidu.com/link?url=J5GeaQ_aSSMscd2pdx3O7nv1xTjZ99hw4ppIODqWFTtGFqHuxw13ppv9HviTZ8IglPkdRudcQb4-expkEoxC_a)，但平常不太会用所以没太在意。我只知道是微软为了替代cmd而特意在Windows 10里添加的新功能 。但在我使用Windows 10 创意者 的时候，正如往常使用鼠标右键+Shift ，本来是**“从此处打开命令窗口”**，结果就是没找到。反而这样显示\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/IKDe87048g.jpg?imageslim)\n后来发现这是微软故意而为之的\n## 什么是PowerShell\n>&#160;&#160;&#160;&#160;Windows PowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用 .NET Framework的强大功能。\n&#160;&#160;&#160;&#160;它引入了许多非常有用的新概念，从而进一步扩展了您在 Windows 命令提示符和 Windows Script Host 环境中获得的知识和创建的脚本。\n&#160;&#160;&#160;&#160;Windows PowerShell v3将伴随着MicrosoftHyper-V3.0和Windows Server 2012发布。PowerShell v3是一个Windows任务自动化的框架，它由一个命令行shell和内置在这个.NET框架上的编程语言组成。\n&#160;&#160;&#160;&#160;PowerShell v3采用新的cmdlet让管理员能够更深入到系统进程中，这些进程可以制作成可执行的文件或脚本（script）。一条cmdlet是一条轻量命令，Windows PowerShell运行时间在自动化脚本的环境里调用它。Cmdlet包括显示当前目录的Get-Location，访问文件内容的Get-Content和结束运行进程的Stop-Process。\n&#160;&#160;&#160;&#160;PowerShell v3在Windows Server 8中装载了Windows Management Framework 3.0。PowerShell运行时间也能嵌入到其它应用。——百度百科\n\n[微软PowerShell官网](https://msdn.microsoft.com/en-us/powershell)\n\n&#160;&#160;&#160;&#160;从Windows10创意者更新开始，PowerShell正式上位替换了命令提示符CMD。不论是Windows+X右键超级菜单，还是Shift+文件夹空白处右键，又或在文件资源管理器文件菜单中，都没有命令提示符CMD的身影了，全部都由PowerShell取而代之了。长期使用CMD的Windows系统管理员或Windows命令行极客恐怕一时不能适应，使用CMD都只能去开始菜单-所有应用-Windows系统-命令提示符打开使用，或者Windows+R键然后输入cmd，或者在小娜输入框输入cmd，再或者在PowerShell中输入cmd(看来又绕回来了)。藏得这么深，显然是不想让人用了啊。不仅如此，Power Shell还登陆了Linux和MacOS  \n[在Linux下安装PowerShell](https://zhuanlan.zhihu.com/p/26346821?utm_source=qq&utm_medium=social)\nPoweShell上位图如下\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/bfiiJCEHd4.jpg?imageslim)\n&#160;&#160;&#160;&#160;问题来了，PowerShell这货凭什么力压CMD，强行上位？如果你之前试用过PowerShell，相信它一定没有给你什么好印象。打开慢！反应慢！命令还陌生！还动不动就弹一大堆谁都看不懂错误，PowerShell究竟凭什么在Windows10创意者更新中替代命令提示符CMD呢？微软脑抽了？\n微软没有脑抽，PowerShell是凭借其强大的功能替换CMD的。这里要先说明以下PowerShell究竟是什么东西，或者它究竟是不是东西？\n&#160;&#160;&#160;&#160;Windows PowerShell不是东西，它是专为系统管理员设计的新Windows命令行shell，它包括交互式提示和脚本环境。PowerShell定义很多命令与操作系统，特别是与文件系统交互，能够启动应用程序，甚至操纵应用程序；PowerShell允许将几个命令组合起来放到文件里执行，实现文件级的重用，也就是说有脚本的性质；PowerShell能够充分利用.Net类型和COM对象，来简单地与各种系统交互，完成各种复杂的、自动化的操作。\n&#160;&#160;&#160;&#160;用人话说就是CMD能做的PowerShell都能做，CMD不能做的Powershell也能做。就是这么自信！不信？赶紧打开PowerShell把下面的命令复制进去，看看它干了什么事，然后你用CMD做出来吧！\n```powershell\n# create new excel instance\n$objExcel = New-Object -comobject Excel.Application\n$objExcel.Visible = $True\n$objWorkbook = $objExcel.Workbooks.Add()\n$objWorksheet = $objWorkbook.Worksheets.Item(1)\n# write information to the excel file\n$i = 0\n$first10 = (ps | sort ws -Descending | select -first 10)\n$first10 | foreach -Process {$i++; $objWorksheet.Cells.Item($i,1) = $_.name; $objWorksheet.Cells.Item($i,2) = $_.ws}\n$otherMem = (ps | measure ws -s).Sum - ($first10 | measure ws -s).Sum\n$objWorksheet.Cells.Item(11,1) = \"Others\"; $objWorksheet.Cells.Item(11,2) = $otherMem\n# draw the pie chart\n$objCharts = $objWorksheet.ChartObjects()\n$objChart = $objCharts.Add(0, 0, 500, 300)\n$objChart.Chart.SetSourceData($objWorksheet.range(\"A1:B11\"), 2)\n$objChart.Chart.ChartType = 70\n$objChart.Chart.ApplyDataLabels(5)\n```\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/CJi70f9ahF.png?imageslim)\n没错，有点慢，等下吧，接下来它自动打开了excel，如图，我果然还是IT之家老粉丝啊\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/B8IDAdFlm4.png?imageslim)\n&#160;&#160;&#160;&#160;上面一段代码是PowerShell界常见的一段神代码，很多初学者被其带入了PowerShell的大门。有效代码不过20来行，作用是把当前系统中最占内存的10个进程的数据发送到Excel中，并绘制成三维饼图。CMD是很难做到了，被替代也理所应当了。\n&#160;&#160;&#160;&#160;PowerShell的定位是操作系统和应用程序的管理工具，从这个角度看，它是CMD的升级版，并非简单的对CMD进行扩展，事实上微软也不打算扩展和升级CMD了，以后PowerShell将全方位的替代CMD，目前CMD和PowerShell还是并存状态。\n下面正式介绍PowerShell。\n### （一）简单的命令\n&#160;&#160;&#160;&#160;在CMD中，命令是从非常简单（如attrib.exe）到非常复杂（如netsh.exe）的可执行程序，新入门用户一旦遇到复杂命令，只能束手无策，只能求助搜索引擎，解决当前需求之后，就把命令的用法抛诸脑后，下次使用又要重新学习，极其不便。\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/526ijlFjLJ.png?imageslim)\n&#160;&#160;&#160;&#160;PowerShell命令设计非常规范，它的命令由“动词”和“名词”两部分组成，比如“get”表示检索数据，“process”表示系统进程，把“get”和“process”组合起来的PowerShell命令就是“get-process”，意思是获取系统进程列表，这种命令在PowerShell中称为“cmdlet（读作“command-let”）”。\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/CIBlH2i1f7.png?imageslim)\n&#160;&#160;&#160;&#160;使用“动词-名词”结构还有一个好处，就是不同的“动词”和“名词”可以自由组合，很少的几个“动词”和“名词”就可以组合出大量的可用命令，使命令记忆量大为降低，只需记住简单的几个词语，就可以使用大量的命令，这是包括命令提示符CMD在内的Shell不具备的，并且不会产生歧义，对新用户非常友好。\n### （二）别名系统\n&#160;&#160;&#160;&#160;“动词-名词”结构的cmdlet固然对新手友好，但也带来了另一个问题，命令名称过长，在命令行交互使用时不方便，在命令行窗口输入命令可以使用Tab键进行补全，可是经常使用还是需要键入大量的内容，要是能够把命令缩短一些就好了。PowerShell在设计时已经考虑到了，为此创建了别名系统，之所以叫名别系统，是因为PowerShell中的别名非常强大，能够非常方便的对别名进行增加、删除、修改，还为之创建了别名驱动器，可以像访问文件系统驱动器一样方便的访问别名驱动器。\nPowerShell非常贴心的为用户创建了大量内置别名，一方面减少了常用命令的输入长度，另一方面也为熟悉其它Shell而不熟悉PowerShell的用户提供了方便，常见Shell如bash、cmd，PowerShell都为用户提供了他们熟悉的别名。下面是可以在Powershell中使用的通用的Cmd.exe和UNIX命令的简短列表。\n**在PowerShell下输入**\n```powershell\nget-alias\n```\n以下只显示了部分，要想查询所有别名请用`alias`命令查询\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/6AghbjEgAg.png?imageslim)\n&#160;&#160;&#160;&#160;PowerShell除了自带别名外，用户自己也可以创建别名，不仅仅可以为cmdlet创建别名，也可以为PowerShell函数、带参数的命令和包含完整路径的命令行程序创建别名。\n比如为记事本创建别名，可以使用如下命令\n```powershell\nNew-Alias np c:\\windows\\notepad.exe\n```\n&#160;&#160;&#160;&#160;创建别名完成后，在命令行中输入np就能直接打开记事本。在命令行中创建的别名只能在当前命令行窗口中使用，如果想以后也能使用此别名，可以把以上命令保存在PowerShell配置文件中，以后无论是在命令行中，还是使用脚本，都可以在本机使用np别名了。\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/8h0kd2FD21.png?imageslim)\nPowrShell配置文件位置可以使用$profile命令查询。\n\n&#160;&#160;&#160;&#160;想查看当前命令行窗口可以使用的别名，可以进入别名驱动器查看，使用dir alias:就能查看所有能用的别名，也可以使用get-alias命令查看别名。\n### (三) 管理任务\nWindows PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，为了达成这个目标，PowerShell提供了大量命令来执行各种管理任务，让用户轻松完成管理系统任务。\n#### 1、管理进程\n前面已经提过管理系统进程的命令，管理进程常用命令就是get-process命令和stop-process命令，get-process命令获取进程之后可以直接用管道发送给stop-process命令结束进程。比如，关闭之前打开的记事本，可以使用下面的命令很方便的关闭记事本。\n```powershell\nget-process -Name notepad | stop-process\n```\n#### 2、处理文件和文件夹\n&#160;&#160;&#160;&#160;PowerShell使用Get-ChildItem获取文件夹中直接包含的所有项，它有系统内置别名dir和ls，使用CMD和BASH的用户均可以轻松上手。如果想查看C:中的文件夹和文件，直接使用dir c:，PowerShell立刻就会列出C:中的文件和文件夹。其它处理文件和文件夹的命令有Copy-Item、New-Item、Remove-Item等，具体用法可以使用get-help然后跟命令名称即可查询。\n#### 3、处理系统服务\n&#160;&#160;&#160;&#160;可以像管理进程一样管理系统服务，Get-Service命令获取服务列表，Stop-Service命令停止服务，Start-Service命令启动服务，Suspend-Service命令挂起服务，Restart-Service命令重启服务，Set-Service服务设置服务属性。如果想一次性启动已经停止的服务，可以使用以下命令：\n```powershell\nget-service | where-object {$_.Status -eq \"Stopped\"} -exclude\nwisvc | start-service\n```\n&#160;&#160;&#160;&#160;这行命名会把除wisvc之外的命令都启动，这只是一个示例，不要在自己电脑使用，启动所有服务会消耗大量系统资源。\n#### 4、处理注册表\n&#160;&#160;&#160;&#160;PowerShell可以非常方便的处理注册表项目，与进程和服务不同的是，PowerShell并未提供专用的注册表命令，而是使用处理文件和文件夹的命令，这并不奇怪，PowerShell为用户提供了注册表驱动器，可以很好的处理注册表项目。由于注册表对系统非常重要，错误处理注册表也许会导致系统出问题，处理注册表，特别是删除注册表项目要非常小心，最好能在处理注册表项目之前先备份要处理的项目。没有管理员权限也能处理部分注册表项目，这与regedit注册表编辑器不同，注册表编辑器必须使用管理员权限打开，然后才能操作项目。\n**下面的表格列出了访问注册表所需的所有命令**\n\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/LcIe6FFlJ4.png?imageslim)\nPowerShell只提供了两个注册表驱动器HKCU:和HKLM:，其中HKLM:是HKEY_LOCAL_MACHINE的缩写，HKCU:是HKEY_CURRENT_USER的缩写，如果想要访问所有注册表驱动器，可以进入Microsoft.PowerShell.Core\\Registry::。\n#### 5、处理其它任务\nPowerShell还可以处理证书、防火墙、appx应用、打印机等任务。大家可以使用get-command命令查找相关命令。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["PowerShell"]},{"title":"我为什么要建立这个博客","url":"/2017/07/04/为什么要建立这个博客/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n建立博客的原因\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 为什么要建立这个博客\n`作者：lovemefan`  [我的GitHub](www.github.com/lovemefan)\n\n>  &#160; &#160;&#160; &#160;我现在是一名即将大三的软件的学生。对编程还谈得上热爱，但至今也只能承认懂得点皮毛。为什么我要写这个博客？根本原因还是“懒”。我需要一个能够鞭策我一直坚持下去的东西。不过我也承认有一点点装B的嫌疑。我个人性格有点不羁，不喜欢按部就班，墨守成规。总想着做点疯狂的事。兴趣与时间总是矛盾的，可是时间又是从海绵里挤出来的。想想大一大二就这样“嗖”一般的过掉了...掉了...了。东西没学到多少，时间就快没了。看到有的同学能做一个看起来就很牛逼的程序，然后讲一堆从来没听过的专业术语。“卧槽！卧槽！！！”，“厉害了，我的哥”，“哇，大神，带我飞”，像这样的话没少听。一般这种时候我都会嫉妒一下。“TM为什么我不会”，“不过，不会也正常，我TM又不是神”，“妈蛋，下次去学，嗯！一定要学会”，“好像也就这样了，先放一放吧”。大多数情况下这件事就被无限延期了。\n  &#160; &#160;&#160; &#160;首先，我总结了一个原因——懒。这种东西确实是人类的天敌，当然不排除某些勤奋已经成了日常的hentai。我有一些类似的经历，写作业写到两三点停不下来，还像打了鸡血一样很兴奋，鬼知道发生了什么。最长的一次在图书馆呆了13多个小时，从早上8点到晚上9点半，丝毫不想走。这种接近痴狂的人生，我个人觉得还蛮不错的。但是，但是，但是我又双叒叕被懒惰打败了，一不小心就荒废了下学业。结果就是期末成绩无情的嘲讽。懒惰这东西迟早，一定，必须面对。所以我觉得有必要做些事情，比如维护这博客。\n &#160; &#160;&#160; &#160;其次，我吐槽下大学现在这个机制不是我想要的。大学也读了一半了，大多数人是这么过的：“上课可以不听，下课我看一下就好了。”，“这题好像老师讲过，不过我忘了。”“学习，学个屁”，“这次考试考哪些重点，帮我画一下”，“最后一个礼拜复习，祈祷不挂”，“复习什么，大家一起挂”，“成绩出来了，吐血，80多”（MD，老子一巴掌。。。）。然而结果不是我所期望的。考试这种东西确实是有存在的必要，但现在的考试总感觉变了味。老师说什么会考，就考什么，可能还是去年的原题。只要刷几套往年试卷，就可以考得很好，于是更多的人在钻研怎么“考试”，而不是解决问题。两年下来，你是更擅长考试，还是更擅长你的专业知识。我非常敬佩那些不以考试为目的教学的老师。就比如说那个陈胖子（没事，他看不到），他上的Java和c语言数据结构还是很有分量的。\n &#160; &#160;&#160; &#160;假设大学四年我都这样过的话，满足吗？能力能提高多少呢？到底能学到多少东西呢？我现在可以C，C++，C#，Java，JavaScript，Matlab，Python...写一个Hello world，这样够吗?有人会说可以了，已经很不错了。可是野心不大一点，目标不远一点，不疯狂一点还是我的风格吗？现在还不疯狂一把，以后还有机会吗？你能保证未来不会因现在后悔吗？\n所以，我建立了在个博客，并且想维护它。我想多学点东西。现在的初心是既可以记录学习的点滴，也可以每时每刻都鞭策着我，因为每更新一次这个东西，就会得到一种“快感”，成就感。更新GitHub时也是一样。私心还是有的，当然希望被人关注了，肯定是越多越好了。\n\n## 博客的内容\n我尽量能写就多写，最近在知乎，CDNS，简书...中看到大量IT干货，激发了我极大的兴趣\n所以想着现在来建立这博客也不迟，算得上是学习了一种记录和鞭策吧\n* 一些学习过程中的问题，解决思路方法。\n* 我感兴趣的事物，可能以后会写测评。\n* GitHub，知乎,IT之家等 一些趣味知识。\n* 开发UWP。我曾经是一名wper（Lumia 1020），早在很久之前就打算学习UWP了，我希望能够坚持下去，尽管可能没有太多的时间和精力。就算是龟速更新，我也不会停止学习的。\n## 计划列表\n* UWP，Android，web(大三必修)\n* UE4(虚幻4)，unity  (项目所需和个人兴趣爱好)\n* 学些脚本语言，待定：PowerShell，JavaScript等\n* 待定"}]